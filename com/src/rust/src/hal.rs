/* automatically generated by rust-bindgen */

#![allow(dead_code,
         non_camel_case_types,
         non_upper_case_globals,
         non_snake_case)]

use ctypes::*;

pub type int8_t = i8;
pub type int16_t = i16;
pub type int32_t = i32;
pub type int64_t = i64;
pub type uint8_t = u8;
pub type uint16_t = u16;
pub type uint32_t = u32;
pub type uint64_t = u64;
pub type int_least8_t = ::ctypes::c_char;
pub type int_least16_t = ::ctypes::c_short;
pub type int_least32_t = ::ctypes::c_int;
pub type int_least64_t = ::ctypes::c_long;
pub type uint_least8_t = ::ctypes::c_uchar;
pub type uint_least16_t = ::ctypes::c_ushort;
pub type uint_least32_t = ::ctypes::c_uint;
pub type uint_least64_t = ::ctypes::c_ulong;
pub type int_fast8_t = ::ctypes::c_char;
pub type int_fast16_t = ::ctypes::c_long;
pub type int_fast32_t = ::ctypes::c_long;
pub type int_fast64_t = ::ctypes::c_long;
pub type uint_fast8_t = ::ctypes::c_uchar;
pub type uint_fast16_t = ::ctypes::c_ulong;
pub type uint_fast32_t = ::ctypes::c_ulong;
pub type uint_fast64_t = ::ctypes::c_ulong;
pub type intptr_t = isize;
pub type uintptr_t = usize;
pub type intmax_t = ::ctypes::c_long;
pub type uintmax_t = ::ctypes::c_ulong;
pub type uint_ = ::ctypes::c_uint;
pub type sint = ::ctypes::c_int;
pub type BOOL = ::ctypes::c_uchar;
pub type bool_ = ::ctypes::c_uchar;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct atomic_t {
    pub counter: ::ctypes::c_int,
}
impl ::core::default::Default for atomic_t {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _RTK_STATUS_ { _EXIT_SUCCESS = 0, _EXIT_FAILURE = 1, }
pub type RTK_STATUS = _RTK_STATUS_;
pub type PRTK_STATUS = *mut _RTK_STATUS_;
pub type PVOID = *mut ::ctypes::c_void;
pub type dma_addr_t = uint32_t;
pub type proc_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::ctypes::c_void)>;
pub type __kernel_size_t = ::ctypes::c_uint;
pub type __kernel_ssize_t = ::ctypes::c_int;
pub type SIZE_T = __kernel_size_t;
pub type SSIZE_T = __kernel_ssize_t;
pub type BOOLEAN = ::ctypes::c_uchar;
pub type PBOOLEAN = *mut ::ctypes::c_uchar;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _RAM_START_FUNCTION_ {
    pub RamStartFun: ::core::option::Option<extern "C" fn()>,
}
impl ::core::default::Default for _RAM_START_FUNCTION_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type RAM_START_FUNCTION = _RAM_START_FUNCTION_;
pub type PRAM_START_FUNCTION = *mut _RAM_START_FUNCTION_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _RAM_FUNCTION_START_TABLE_ {
    pub RamStartFun: ::core::option::Option<extern "C" fn()>,
    pub RamWakeupFun: ::core::option::Option<extern "C" fn()>,
    pub RamPatchFun0: ::core::option::Option<extern "C" fn()>,
    pub RamPatchFun1: ::core::option::Option<extern "C" fn()>,
    pub RamPatchFun2: ::core::option::Option<extern "C" fn()>,
}
impl ::core::default::Default for _RAM_FUNCTION_START_TABLE_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type RAM_FUNCTION_START_TABLE = _RAM_FUNCTION_START_TABLE_;
pub type PRAM_FUNCTION_START_TABLE = *mut _RAM_FUNCTION_START_TABLE_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _BOOT_TYPE_ {
    BOOT_FROM_FLASH = 0,
    BOOT_FROM_SDIO = 1,
    BOOT_FROM_USB = 2,
    BOOT_FROM_RSVD = 3,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _EFUSE_CPU_CLK_ {
    CLK_200M = 0,
    CLK_100M = 1,
    CLK_50M = 2,
    CLK_25M = 3,
    CLK_12_5M = 4,
    CLK_4M = 5,
}
#[derive(Copy, Clone)]
#[repr(i32)]
#[derive(Debug)]
pub enum _IRQn_Type_ {
    NonMaskableInt_IRQn = -14,
    HardFault_IRQn = -13,
    MemoryManagement_IRQn = -12,
    BusFault_IRQn = -11,
    UsageFault_IRQn = -10,
    SVCall_IRQn = -5,
    DebugMonitor_IRQn = -4,
    PendSV_IRQn = -2,
    SysTick_IRQn = -1,
    SYSTEM_ON_IRQ = 0,
    WDG_IRQ = 1,
    TIMER0_IRQ = 2,
    TIMER1_IRQ = 3,
    I2C3_IRQ = 4,
    TIMER2_7_IRQ = 5,
    SPI0_IRQ = 6,
    GPIO_IRQ = 7,
    UART0_IRQ = 8,
    SPI_FLASH_IRQ = 9,
    USB_OTG_IRQ = 10,
    SDIO_HOST_IRQ = 11,
    SDIO_DEVICE_IRQ = 12,
    I2S0_PCM0_IRQ = 13,
    I2S1_PCM1_IRQ = 14,
    WL_DMA_IRQ = 15,
    WL_PROTOCOL_IRQ = 16,
    CRYPTO_IRQ = 17,
    GMAC_IRQ = 18,
    PERIPHERAL_IRQ = 19,
    GDMA0_CHANNEL0_IRQ = 20,
    GDMA0_CHANNEL1_IRQ = 21,
    GDMA0_CHANNEL2_IRQ = 22,
    GDMA0_CHANNEL3_IRQ = 23,
    GDMA0_CHANNEL4_IRQ = 24,
    GDMA0_CHANNEL5_IRQ = 25,
    GDMA1_CHANNEL0_IRQ = 26,
    GDMA1_CHANNEL1_IRQ = 27,
    GDMA1_CHANNEL2_IRQ = 28,
    GDMA1_CHANNEL3_IRQ = 29,
    GDMA1_CHANNEL4_IRQ = 30,
    GDMA1_CHANNEL5_IRQ = 31,
    I2C0_IRQ = 64,
    I2C1_IRQ = 65,
    I2C2_IRQ = 66,
    SPI1_IRQ = 72,
    SPI2_IRQ = 73,
    UART1_IRQ = 80,
    UART2_IRQ = 81,
    UART_LOG_IRQ = 88,
    ADC_IRQ = 89,
    DAC0_IRQ = 91,
    DAC1_IRQ = 92,
    LP_EXTENSION_IRQ = 93,
    PTA_TRX_IRQ = 95,
    RXI300_IRQ = 96,
    NFC_IRQ = 97,
}
pub type IRQn_Type = _IRQn_Type_;
pub type PIRQn_Type = *mut _IRQn_Type_;
pub type HAL_VECTOR_FUN = ::core::option::Option<extern "C" fn()>;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _VECTOR_TABLE_TYPE_ {
    DEDECATED_VECTRO_TABLE = 0,
    PERIPHERAL_VECTOR_TABLE = 1,
}
pub type VECTOR_TABLE_TYPE = _VECTOR_TABLE_TYPE_;
pub type PVECTOR_TABLE_TYPE = *mut _VECTOR_TABLE_TYPE_;
pub type IRQ_FUN =
    ::core::option::Option<unsafe extern "C" fn(Data: *mut ::ctypes::c_void)>;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _IRQ_HANDLE_ {
    pub IrqFun: IRQ_FUN,
    pub IrqNum: IRQn_Type,
    pub Data: uint32_t,
    pub Priority: uint32_t,
}
impl ::core::default::Default for _IRQ_HANDLE_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type IRQ_HANDLE = _IRQ_HANDLE_;
pub type PIRQ_HANDLE = *mut _IRQ_HANDLE_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _HAL_Status {
    HAL_OK = 0,
    HAL_BUSY = 1,
    HAL_TIMEOUT = 2,
    HAL_ERR_PARA = 3,
    HAL_ERR_MEM = 4,
    HAL_ERR_HW = 5,
    HAL_ERR_UNKNOWN = 238,
}
pub type HAL_Status = _HAL_Status;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _HAL_RESET_REASON {
    REASON_DEFAULT_RST = 0,
    REASON_WDT_RST = 1,
    REASON_EXCEPTION_RST = 2,
    REASON_SOFT_WDT_RST = 3,
    REASON_SOFT_RESTART = 4,
    REASON_DEEP_SLEEP_AWAKE = 5,
    REASON_EXT_SYS_RST = 6,
}
pub type HAL_RESET_REASON = uint32_t;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _LOG_UART_ADAPTER_ {
    pub BaudRate: uint32_t,
    pub FIFOControl: uint32_t,
    pub IntEnReg: uint32_t,
    pub Parity: uint8_t,
    pub Stop: uint8_t,
    pub DataLength: uint8_t,
}
impl ::core::default::Default for _LOG_UART_ADAPTER_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type LOG_UART_ADAPTER = _LOG_UART_ADAPTER_;
pub type PLOG_UART_ADAPTER = *mut _LOG_UART_ADAPTER_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _COMMAND_TABLE_ {
    pub cmd: *const uint8_t,
    pub ArgvCnt: uint16_t,
    pub func: ::core::option::Option<extern "C" fn(argc: uint16_t,
                                                   argv: *mut *mut uint8_t)
                                         -> uint32_t>,
    pub msg: *const uint8_t,
}
impl ::core::default::Default for _COMMAND_TABLE_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type COMMAND_TABLE = _COMMAND_TABLE_;
pub type PCOMMAND_TABLE = *mut _COMMAND_TABLE_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _SPIC_PARA_MODE_ {
    pub _bindgen_bitfield_1_: uint8_t,
    pub _bindgen_bitfield_2_: uint8_t,
    pub _bindgen_bitfield_3_: uint8_t,
    pub _bindgen_bitfield_4_: uint8_t,
}
impl ::core::default::Default for _SPIC_PARA_MODE_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type SPIC_PARA_MODE = _SPIC_PARA_MODE_;
pub type PSPIC_PARA_MODE = *mut _SPIC_PARA_MODE_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _SPIC_INIT_PARA_ {
    pub BaudRate: uint8_t,
    pub RdDummyCyle: uint8_t,
    pub DelayLine: uint8_t,
    pub _bindgen_data_1_: [u8; 1usize],
    pub id: [uint8_t; 3usize],
    pub flashtype: uint8_t,
}
impl _SPIC_INIT_PARA_ {
    pub unsafe fn Rsvd(&mut self) -> *mut uint8_t {
        let raw: *mut u8 = ::core::mem::transmute(&self._bindgen_data_1_);
        ::core::mem::transmute(raw.offset(0))
    }
    pub unsafe fn Valid(&mut self) -> *mut uint8_t {
        let raw: *mut u8 = ::core::mem::transmute(&self._bindgen_data_1_);
        ::core::mem::transmute(raw.offset(0))
    }
    pub unsafe fn Mode(&mut self) -> *mut SPIC_PARA_MODE {
        let raw: *mut u8 = ::core::mem::transmute(&self._bindgen_data_1_);
        ::core::mem::transmute(raw.offset(0))
    }
}
impl ::core::default::Default for _SPIC_INIT_PARA_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type SPIC_INIT_PARA = _SPIC_INIT_PARA_;
pub type PSPIC_INIT_PARA = *mut _SPIC_INIT_PARA_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _SPIC_BIT_MODE_ {
    SpicOneBitMode = 0,
    SpicDualBitMode = 1,
    SpicQuadBitMode = 2,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _TIMER_MODE_ { FREE_RUN_MODE = 0, USER_DEFINED = 1, }
pub type TIMER_MODE = _TIMER_MODE_;
pub type PTIMER_MODE = *mut _TIMER_MODE_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _TIMER_ADAPTER_ {
    pub TimerLoadValueUs: uint32_t,
    pub TimerIrqPriority: uint32_t,
    pub TimerMode: TIMER_MODE,
    pub IrqHandle: IRQ_HANDLE,
    pub TimerId: uint8_t,
    pub IrqDis: uint8_t,
}
impl ::core::default::Default for _TIMER_ADAPTER_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type TIMER_ADAPTER = _TIMER_ADAPTER_;
pub type PTIMER_ADAPTER = *mut _TIMER_ADAPTER_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _HAL_TIMER_OP_ {
    pub HalGetTimerId: ::core::option::Option<unsafe extern "C" fn(TimerId:
                                                                       *mut uint32_t)
                                                  -> uint32_t>,
    pub HalTimerInit: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                      *mut ::ctypes::c_void)
                                                 -> BOOL>,
    pub HalTimerReadCount: ::core::option::Option<extern "C" fn(TimerId:
                                                                    uint32_t)
                                                      -> uint32_t>,
    pub HalTimerIrqClear: ::core::option::Option<extern "C" fn(TimerId:
                                                                   uint32_t)>,
    pub HalTimerDis: ::core::option::Option<extern "C" fn(TimerId: uint32_t)>,
    pub HalTimerEn: ::core::option::Option<extern "C" fn(TimerId: uint32_t)>,
    pub HalTimerDumpReg: ::core::option::Option<extern "C" fn(TimerId:
                                                                  uint32_t)>,
}
impl ::core::default::Default for _HAL_TIMER_OP_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type HAL_TIMER_OP = _HAL_TIMER_OP_;
pub type PHAL_TIMER_OP = *mut _HAL_TIMER_OP_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct LIST_HEADER {
    pub Next: *mut LIST_HEADER,
    pub Prev: *mut LIST_HEADER,
}
impl ::core::default::Default for LIST_HEADER {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type _LIST = LIST_HEADER;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum power_state_idx {
    ACT = 0,
    WFE = 1,
    WFI = 2,
    SNOOZE = 3,
    SLPCG = 4,
    SLPPG = 5,
    DSTBY = 6,
    DSLP = 7,
    INACT = 8,
    MAXSTATE = 9,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum clk_idx { ANACK = 0, A33CK = 1, }
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _power_state_ {
    pub FuncIdx: uint8_t,
    pub PowerState: uint8_t,
}
impl ::core::default::Default for _power_state_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type POWER_STATE = _power_state_;
pub type pPOWER_STATE = *mut _power_state_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _reg_power_state_ {
    pub FuncIdx: uint8_t,
    pub PwrState: uint8_t,
}
impl ::core::default::Default for _reg_power_state_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type REG_POWER_STATE = _reg_power_state_;
pub type pPREG_POWER_STATE = *mut _reg_power_state_;
#[repr(C)]
#[derive(Copy)]
pub struct _power_mgn_ {
    pub ActFuncCount: uint8_t,
    pub PwrState: [POWER_STATE; 10usize],
    pub CurrentState: uint8_t,
    pub SDREn: uint8_t,
    pub MSPbackup: [uint32_t; 129usize],
    pub CPURegbackup: [uint32_t; 25usize],
    pub CPUPSP: uint32_t,
    pub WakeEventFlag: uint32_t,
    pub SleepFlag: BOOL,
}
impl ::core::clone::Clone for _power_mgn_ {
    fn clone(&self) -> Self { *self }
}
impl ::core::default::Default for _power_mgn_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type Power_Mgn = _power_mgn_;
pub type pPower_Mgn = *mut _power_mgn_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _SYS_ADAPTER_ {
    pub function: uint8_t,
}
impl ::core::default::Default for _SYS_ADAPTER_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type SYS_ADAPTER = _SYS_ADAPTER_;
pub type PSYS_ADAPTER = *mut _SYS_ADAPTER_;
pub type ptrdiff_t = isize;
pub type size_t = usize;
pub type wchar_t = ::ctypes::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::ctypes::c_longlong,
    pub __clang_max_align_nonce2: f64,
}
impl ::core::default::Default for max_align_t {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _SYSTEM_DBG_DEFINE_ {
    _SYSDBG_MISC_ = 1,
    _SYSDBG_MAILBOX_ = 2,
    _SYSDBG_TIMER_ = 4,
}
pub type SYSTEM_DBG = _SYSTEM_DBG_DEFINE_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _DBG_CFG_TYPE_ {
    DBG_CFG_ERR = 0,
    DBG_CFG_WARN = 1,
    DBG_CFG_INFO = 2,
}
pub type DBG_CFG_TYPE = _DBG_CFG_TYPE_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _DBG_CFG_CMD_ {
    pub cmd_name: [uint8_t; 16usize],
    pub cmd_type: uint32_t,
}
impl ::core::default::Default for _DBG_CFG_CMD_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type DBG_CFG_CMD = _DBG_CFG_CMD_;
pub type PDBG_CFG_CMD = *mut _DBG_CFG_CMD_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _CONSOLE_OP_STAGE_ { ROM_STAGE = 0, RAM_STAGE = 1, }
pub type CONSOLE_OP_STAGE = _CONSOLE_OP_STAGE_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct APSR_Type {
    pub _bindgen_data_: [u32; 1usize],
}
impl APSR_Type {
    pub unsafe fn b(&mut self) -> *mut Struct_Unnamed1 {
        let raw: *mut u8 = ::core::mem::transmute(&self._bindgen_data_);
        ::core::mem::transmute(raw.offset(0))
    }
    pub unsafe fn w(&mut self) -> *mut uint32_t {
        let raw: *mut u8 = ::core::mem::transmute(&self._bindgen_data_);
        ::core::mem::transmute(raw.offset(0))
    }
}
impl ::core::default::Default for APSR_Type {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct Struct_Unnamed1 {
    pub _bindgen_bitfield_1_: uint32_t,
    pub _bindgen_bitfield_2_: uint32_t,
    pub _bindgen_bitfield_3_: uint32_t,
    pub _bindgen_bitfield_4_: uint32_t,
    pub _bindgen_bitfield_5_: uint32_t,
    pub _bindgen_bitfield_6_: uint32_t,
}
impl ::core::default::Default for Struct_Unnamed1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct IPSR_Type {
    pub _bindgen_data_: [u32; 1usize],
}
impl IPSR_Type {
    pub unsafe fn b(&mut self) -> *mut Struct_Unnamed2 {
        let raw: *mut u8 = ::core::mem::transmute(&self._bindgen_data_);
        ::core::mem::transmute(raw.offset(0))
    }
    pub unsafe fn w(&mut self) -> *mut uint32_t {
        let raw: *mut u8 = ::core::mem::transmute(&self._bindgen_data_);
        ::core::mem::transmute(raw.offset(0))
    }
}
impl ::core::default::Default for IPSR_Type {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct Struct_Unnamed2 {
    pub _bindgen_bitfield_1_: uint32_t,
    pub _bindgen_bitfield_2_: uint32_t,
}
impl ::core::default::Default for Struct_Unnamed2 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct xPSR_Type {
    pub _bindgen_data_: [u32; 1usize],
}
impl xPSR_Type {
    pub unsafe fn b(&mut self) -> *mut Struct_Unnamed3 {
        let raw: *mut u8 = ::core::mem::transmute(&self._bindgen_data_);
        ::core::mem::transmute(raw.offset(0))
    }
    pub unsafe fn w(&mut self) -> *mut uint32_t {
        let raw: *mut u8 = ::core::mem::transmute(&self._bindgen_data_);
        ::core::mem::transmute(raw.offset(0))
    }
}
impl ::core::default::Default for xPSR_Type {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct Struct_Unnamed3 {
    pub _bindgen_bitfield_1_: uint32_t,
    pub _bindgen_bitfield_2_: uint32_t,
    pub _bindgen_bitfield_3_: uint32_t,
    pub _bindgen_bitfield_4_: uint32_t,
    pub _bindgen_bitfield_5_: uint32_t,
    pub _bindgen_bitfield_6_: uint32_t,
    pub _bindgen_bitfield_7_: uint32_t,
    pub _bindgen_bitfield_8_: uint32_t,
    pub _bindgen_bitfield_9_: uint32_t,
}
impl ::core::default::Default for Struct_Unnamed3 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct CONTROL_Type {
    pub _bindgen_data_: [u32; 1usize],
}
impl CONTROL_Type {
    pub unsafe fn b(&mut self) -> *mut Struct_Unnamed4 {
        let raw: *mut u8 = ::core::mem::transmute(&self._bindgen_data_);
        ::core::mem::transmute(raw.offset(0))
    }
    pub unsafe fn w(&mut self) -> *mut uint32_t {
        let raw: *mut u8 = ::core::mem::transmute(&self._bindgen_data_);
        ::core::mem::transmute(raw.offset(0))
    }
}
impl ::core::default::Default for CONTROL_Type {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct Struct_Unnamed4 {
    pub _bindgen_bitfield_1_: uint32_t,
    pub _bindgen_bitfield_2_: uint32_t,
    pub _bindgen_bitfield_3_: uint32_t,
    pub _bindgen_bitfield_4_: uint32_t,
}
impl ::core::default::Default for Struct_Unnamed4 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct NVIC_Type {
    pub ISER: [uint32_t; 8usize],
    pub RESERVED0: [uint32_t; 24usize],
    pub ICER: [uint32_t; 8usize],
    pub RSERVED1: [uint32_t; 24usize],
    pub ISPR: [uint32_t; 8usize],
    pub RESERVED2: [uint32_t; 24usize],
    pub ICPR: [uint32_t; 8usize],
    pub RESERVED3: [uint32_t; 24usize],
    pub IABR: [uint32_t; 8usize],
    pub RESERVED4: [uint32_t; 56usize],
    pub IP: [uint8_t; 240usize],
    pub RESERVED5: [uint32_t; 644usize],
    pub STIR: uint32_t,
}
impl ::core::clone::Clone for NVIC_Type {
    fn clone(&self) -> Self { *self }
}
impl ::core::default::Default for NVIC_Type {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct SCB_Type {
    pub CPUID: uint32_t,
    pub ICSR: uint32_t,
    pub VTOR: uint32_t,
    pub AIRCR: uint32_t,
    pub SCR: uint32_t,
    pub CCR: uint32_t,
    pub SHP: [uint8_t; 12usize],
    pub SHCSR: uint32_t,
    pub CFSR: uint32_t,
    pub HFSR: uint32_t,
    pub DFSR: uint32_t,
    pub MMFAR: uint32_t,
    pub BFAR: uint32_t,
    pub AFSR: uint32_t,
    pub PFR: [uint32_t; 2usize],
    pub DFR: uint32_t,
    pub ADR: uint32_t,
    pub MMFR: [uint32_t; 4usize],
    pub ISAR: [uint32_t; 5usize],
    pub RESERVED0: [uint32_t; 5usize],
    pub CPACR: uint32_t,
}
impl ::core::default::Default for SCB_Type {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct SCnSCB_Type {
    pub RESERVED0: [uint32_t; 1usize],
    pub ICTR: uint32_t,
    pub ACTLR: uint32_t,
}
impl ::core::default::Default for SCnSCB_Type {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct SysTick_Type {
    pub CTRL: uint32_t,
    pub LOAD: uint32_t,
    pub VAL: uint32_t,
    pub CALIB: uint32_t,
}
impl ::core::default::Default for SysTick_Type {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct ITM_Type {
    pub PORT: [Union_Unnamed5; 32usize],
    pub RESERVED0: [uint32_t; 864usize],
    pub TER: uint32_t,
    pub RESERVED1: [uint32_t; 15usize],
    pub TPR: uint32_t,
    pub RESERVED2: [uint32_t; 15usize],
    pub TCR: uint32_t,
    pub RESERVED3: [uint32_t; 29usize],
    pub IWR: uint32_t,
    pub IRR: uint32_t,
    pub IMCR: uint32_t,
    pub RESERVED4: [uint32_t; 43usize],
    pub LAR: uint32_t,
    pub LSR: uint32_t,
    pub RESERVED5: [uint32_t; 6usize],
    pub PID4: uint32_t,
    pub PID5: uint32_t,
    pub PID6: uint32_t,
    pub PID7: uint32_t,
    pub PID0: uint32_t,
    pub PID1: uint32_t,
    pub PID2: uint32_t,
    pub PID3: uint32_t,
    pub CID0: uint32_t,
    pub CID1: uint32_t,
    pub CID2: uint32_t,
    pub CID3: uint32_t,
}
impl ::core::clone::Clone for ITM_Type {
    fn clone(&self) -> Self { *self }
}
impl ::core::default::Default for ITM_Type {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct Union_Unnamed5 {
    pub _bindgen_data_: [u32; 1usize],
}
impl Union_Unnamed5 {
    pub unsafe fn uint8_t(&mut self) -> *mut uint8_t {
        let raw: *mut u8 = ::core::mem::transmute(&self._bindgen_data_);
        ::core::mem::transmute(raw.offset(0))
    }
    pub unsafe fn uint16_t(&mut self) -> *mut uint16_t {
        let raw: *mut u8 = ::core::mem::transmute(&self._bindgen_data_);
        ::core::mem::transmute(raw.offset(0))
    }
    pub unsafe fn uint32_t(&mut self) -> *mut uint32_t {
        let raw: *mut u8 = ::core::mem::transmute(&self._bindgen_data_);
        ::core::mem::transmute(raw.offset(0))
    }
}
impl ::core::default::Default for Union_Unnamed5 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct DWT_Type {
    pub CTRL: uint32_t,
    pub CYCCNT: uint32_t,
    pub CPICNT: uint32_t,
    pub EXCCNT: uint32_t,
    pub SLEEPCNT: uint32_t,
    pub LSUCNT: uint32_t,
    pub FOLDCNT: uint32_t,
    pub PCSR: uint32_t,
    pub COMP0: uint32_t,
    pub MASK0: uint32_t,
    pub FUNCTION0: uint32_t,
    pub RESERVED0: [uint32_t; 1usize],
    pub COMP1: uint32_t,
    pub MASK1: uint32_t,
    pub FUNCTION1: uint32_t,
    pub RESERVED1: [uint32_t; 1usize],
    pub COMP2: uint32_t,
    pub MASK2: uint32_t,
    pub FUNCTION2: uint32_t,
    pub RESERVED2: [uint32_t; 1usize],
    pub COMP3: uint32_t,
    pub MASK3: uint32_t,
    pub FUNCTION3: uint32_t,
}
impl ::core::default::Default for DWT_Type {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct TPI_Type {
    pub SSPSR: uint32_t,
    pub CSPSR: uint32_t,
    pub RESERVED0: [uint32_t; 2usize],
    pub ACPR: uint32_t,
    pub RESERVED1: [uint32_t; 55usize],
    pub SPPR: uint32_t,
    pub RESERVED2: [uint32_t; 131usize],
    pub FFSR: uint32_t,
    pub FFCR: uint32_t,
    pub FSCR: uint32_t,
    pub RESERVED3: [uint32_t; 759usize],
    pub TRIGGER: uint32_t,
    pub FIFO0: uint32_t,
    pub ITATBCTR2: uint32_t,
    pub RESERVED4: [uint32_t; 1usize],
    pub ITATBCTR0: uint32_t,
    pub FIFO1: uint32_t,
    pub ITCTRL: uint32_t,
    pub RESERVED5: [uint32_t; 39usize],
    pub CLAIMSET: uint32_t,
    pub CLAIMCLR: uint32_t,
    pub RESERVED7: [uint32_t; 8usize],
    pub DEVID: uint32_t,
    pub DEVTYPE: uint32_t,
}
impl ::core::clone::Clone for TPI_Type {
    fn clone(&self) -> Self { *self }
}
impl ::core::default::Default for TPI_Type {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct MPU_Type {
    pub TYPE: uint32_t,
    pub CTRL: uint32_t,
    pub RNR: uint32_t,
    pub RBAR: uint32_t,
    pub RASR: uint32_t,
    pub RBAR_A1: uint32_t,
    pub RASR_A1: uint32_t,
    pub RBAR_A2: uint32_t,
    pub RASR_A2: uint32_t,
    pub RBAR_A3: uint32_t,
    pub RASR_A3: uint32_t,
}
impl ::core::default::Default for MPU_Type {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct CoreDebug_Type {
    pub DHCSR: uint32_t,
    pub DCRSR: uint32_t,
    pub DCRDR: uint32_t,
    pub DEMCR: uint32_t,
}
impl ::core::default::Default for CoreDebug_Type {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _GDMA_CHANNEL_NUM_ {
    GdmaNoCh = 0,
    GdmaCh0 = 257,
    GdmaCh1 = 514,
    GdmaCh2 = 1028,
    GdmaCh3 = 2056,
    GdmaCh4 = 4112,
    GdmaCh5 = 8224,
    GdmaCh6 = 16448,
    GdmaCh7 = 32896,
    GdmaAllCh = 65535,
}
pub type GDMA_CHANNEL_NUM = _GDMA_CHANNEL_NUM_;
pub type PGDMA_CHANNEL_NUM = *mut _GDMA_CHANNEL_NUM_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _GDMA_CTL_TT_FC_TYPE_ {
    TTFCMemToMem = 0,
    TTFCMemToPeri = 1,
    TTFCPeriToMem = 2,
}
pub type GDMA_CTL_TT_FC_TYPE = _GDMA_CTL_TT_FC_TYPE_;
pub type PGDMA_CTL_TT_FC_TYPE = *mut _GDMA_CTL_TT_FC_TYPE_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _GDMA_CTL_TR_WIDTH_ {
    TrWidthOneByte = 0,
    TrWidthTwoBytes = 1,
    TrWidthFourBytes = 2,
}
pub type GDMA_CTL_TR_WIDTH = _GDMA_CTL_TR_WIDTH_;
pub type PGDMA_CTL_TR_WIDTH = *mut _GDMA_CTL_TR_WIDTH_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _GDMA_CTL_MSIZE_ { MsizeOne = 0, MsizeFour = 1, MsizeEight = 2, }
pub type GDMA_CTL_MSIZE = _GDMA_CTL_MSIZE_;
pub type PGDMA_CTL_MSIZE = *mut _GDMA_CTL_MSIZE_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _GDMA_INC_TYPE_ { IncType = 0, DecType = 1, NoChange = 2, }
pub type GDMA_INC_TYPE = _GDMA_INC_TYPE_;
pub type PGDMA_INC_TYPE = *mut _GDMA_INC_TYPE_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _GDMA_CTL_REG_ {
    pub TtFc: GDMA_CTL_TT_FC_TYPE,
    pub DstTrWidth: GDMA_CTL_TR_WIDTH,
    pub SrcTrWidth: GDMA_CTL_TR_WIDTH,
    pub Dinc: GDMA_INC_TYPE,
    pub Sinc: GDMA_INC_TYPE,
    pub DestMsize: GDMA_CTL_MSIZE,
    pub SrcMsize: GDMA_CTL_MSIZE,
    pub _bindgen_bitfield_1_: uint8_t,
    pub _bindgen_bitfield_2_: uint8_t,
    pub _bindgen_bitfield_3_: uint8_t,
    pub _bindgen_bitfield_4_: uint8_t,
    pub _bindgen_bitfield_5_: uint8_t,
    pub _bindgen_bitfield_6_: uint8_t,
    pub _bindgen_bitfield_7_: uint8_t,
    pub BlockSize: uint16_t,
}
impl ::core::default::Default for _GDMA_CTL_REG_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type GDMA_CTL_REG = _GDMA_CTL_REG_;
pub type PGDMA_CTL_REG = *mut _GDMA_CTL_REG_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _GDMA_CH_PRIORITY_ {
    Prior0 = 0,
    Prior1 = 1,
    Prior2 = 2,
    Prior3 = 3,
    Prior4 = 4,
    Prior5 = 5,
    Prior6 = 6,
    Prior7 = 7,
}
pub type GDMA_CH_PRIORITY = _GDMA_CH_PRIORITY_;
pub type PGDMA_CH_PRIORITY = *mut _GDMA_CH_PRIORITY_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _GDMA_LOCK_LEVEL_ {
    OverComplDmaTransfer = 0,
    OverComplDmaBlockTransfer = 1,
    OverComplDmaTransation = 2,
}
pub type GDMA_LOCK_LEVEL = _GDMA_LOCK_LEVEL_;
pub type PGDMA_LOCK_LEVEL = *mut _GDMA_LOCK_LEVEL_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _GDMA_CFG_REG_ {
    pub ChPrior: GDMA_CH_PRIORITY,
    pub LockBL: GDMA_LOCK_LEVEL,
    pub LockChL: GDMA_LOCK_LEVEL,
    pub MaxAbrst: uint16_t,
    pub SrcPer: uint8_t,
    pub DestPer: uint8_t,
    pub _bindgen_bitfield_1_: uint16_t,
    pub _bindgen_bitfield_2_: uint16_t,
    pub _bindgen_bitfield_3_: uint16_t,
    pub _bindgen_bitfield_4_: uint16_t,
    pub _bindgen_bitfield_5_: uint16_t,
    pub _bindgen_bitfield_6_: uint16_t,
    pub _bindgen_bitfield_7_: uint16_t,
    pub _bindgen_bitfield_8_: uint16_t,
    pub _bindgen_bitfield_9_: uint16_t,
    pub _bindgen_bitfield_10_: uint16_t,
    pub _bindgen_bitfield_11_: uint16_t,
    pub _bindgen_bitfield_12_: uint16_t,
    pub _bindgen_bitfield_13_: uint16_t,
    pub _bindgen_bitfield_14_: uint16_t,
}
impl ::core::default::Default for _GDMA_CFG_REG_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type GDMA_CFG_REG = _GDMA_CFG_REG_;
pub type PGDMA_CFG_REG = *mut _GDMA_CFG_REG_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _GDMA_ISR_TYPE_ {
    TransferType = 1,
    BlockType = 2,
    SrcTransferType = 4,
    DstTransferType = 8,
    ErrType = 16,
}
pub type GDMA_ISR_TYPE = _GDMA_ISR_TYPE_;
pub type PGDMA_ISR_TYPE = *mut _GDMA_ISR_TYPE_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _GDMA_CH_LLI_ELE_ {
    pub Sarx: uint32_t,
    pub Darx: uint32_t,
    pub Llpx: uint32_t,
    pub CtlxLow: uint32_t,
    pub CtlxUp: uint32_t,
    pub Temp: uint32_t,
}
impl ::core::default::Default for _GDMA_CH_LLI_ELE_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type GDMA_CH_LLI_ELE = _GDMA_CH_LLI_ELE_;
pub type PGDMA_CH_LLI_ELE = *mut _GDMA_CH_LLI_ELE_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct GDMA_CH_LLI {
    pub pLliEle: PGDMA_CH_LLI_ELE,
    pub pNextLli: *mut GDMA_CH_LLI,
}
impl ::core::default::Default for GDMA_CH_LLI {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct BLOCK_SIZE_LIST {
    pub BlockSize: uint32_t,
    pub pNextBlockSiz: *mut BLOCK_SIZE_LIST,
}
impl ::core::default::Default for BLOCK_SIZE_LIST {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _HAL_GDMA_ADAPTER_ {
    pub ChSar: uint32_t,
    pub ChDar: uint32_t,
    pub ChEn: GDMA_CHANNEL_NUM,
    pub GdmaCtl: GDMA_CTL_REG,
    pub GdmaCfg: GDMA_CFG_REG,
    pub PacketLen: uint32_t,
    pub BlockLen: uint32_t,
    pub MuliBlockCunt: uint32_t,
    pub MaxMuliBlock: uint32_t,
    pub pLlix: *mut GDMA_CH_LLI,
    pub pBlockSizeList: *mut BLOCK_SIZE_LIST,
    pub pLli: PGDMA_CH_LLI_ELE,
    pub NextPlli: uint32_t,
    pub TestItem: uint8_t,
    pub ChNum: uint8_t,
    pub GdmaIndex: uint8_t,
    pub _bindgen_bitfield_1_: uint8_t,
    pub _bindgen_bitfield_2_: uint8_t,
    pub _bindgen_bitfield_3_: uint8_t,
    pub _bindgen_bitfield_4_: uint8_t,
    pub _bindgen_bitfield_5_: uint8_t,
    pub GdmaIsrType: uint8_t,
}
impl ::core::default::Default for _HAL_GDMA_ADAPTER_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type HAL_GDMA_ADAPTER = _HAL_GDMA_ADAPTER_;
pub type PHAL_GDMA_ADAPTER = *mut _HAL_GDMA_ADAPTER_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _HAL_GDMA_CHNL_ {
    pub GdmaIndx: uint8_t,
    pub GdmaChnl: uint8_t,
    pub IrqNum: uint8_t,
    pub Reserved: uint8_t,
}
impl ::core::default::Default for _HAL_GDMA_CHNL_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type HAL_GDMA_CHNL = _HAL_GDMA_CHNL_;
pub type PHAL_GDMA_CHNL = *mut _HAL_GDMA_CHNL_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _HAL_GDMA_BLOCK_ {
    pub SrcAddr: uint32_t,
    pub DstAddr: uint32_t,
    pub BlockLength: uint32_t,
    pub SrcOffset: uint32_t,
    pub DstOffset: uint32_t,
}
impl ::core::default::Default for _HAL_GDMA_BLOCK_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type HAL_GDMA_BLOCK = _HAL_GDMA_BLOCK_;
pub type PHAL_GDMA_BLOCK = *mut _HAL_GDMA_BLOCK_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _HAL_GDMA_OP_ {
    pub HalGdmaOnOff: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                      *mut ::ctypes::c_void)>,
    pub HalGdamChInit: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                       *mut ::ctypes::c_void)
                                                  -> BOOL>,
    pub HalGdmaChSeting: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                         *mut ::ctypes::c_void)
                                                    -> BOOL>,
    pub HalGdmaChBlockSeting: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                              *mut ::ctypes::c_void)
                                                         -> BOOL>,
    pub HalGdmaChDis: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                      *mut ::ctypes::c_void)>,
    pub HalGdmaChEn: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                     *mut ::ctypes::c_void)>,
    pub HalGdmaChIsrEnAndDis: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                              *mut ::ctypes::c_void)>,
    pub HalGdmaChIsrClean: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                           *mut ::ctypes::c_void)
                                                      -> uint8_t>,
    pub HalGdmaChCleanAutoSrc: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                               *mut ::ctypes::c_void)>,
    pub HalGdmaChCleanAutoDst: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                               *mut ::ctypes::c_void)>,
}
impl ::core::default::Default for _HAL_GDMA_OP_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type HAL_GDMA_OP = _HAL_GDMA_OP_;
pub type PHAL_GDMA_OP = *mut _HAL_GDMA_OP_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _HAL_GDMA_OBJ_ {
    pub HalGdmaAdapter: HAL_GDMA_ADAPTER,
    pub GdmaIrqHandle: IRQ_HANDLE,
    pub GdmaChLli: [GDMA_CH_LLI_ELE; 16usize],
    pub Lli: [GDMA_CH_LLI; 16usize],
    pub BlockSizeList: [BLOCK_SIZE_LIST; 16usize],
    pub Busy: uint8_t,
    pub BlockNum: uint8_t,
}
impl ::core::default::Default for _HAL_GDMA_OBJ_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type HAL_GDMA_OBJ = _HAL_GDMA_OBJ_;
pub type PHAL_GDMA_OBJ = *mut _HAL_GDMA_OBJ_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum HAL_GPIO_PORT_NAME {
    _PORT_A = 0,
    _PORT_B = 1,
    _PORT_C = 2,
    _PORT_D = 3,
    _PORT_E = 4,
    _PORT_F = 5,
    _PORT_G = 6,
    _PORT_H = 7,
    _PORT_I = 8,
    _PORT_J = 9,
    _PORT_K = 10,
    _PORT_MAX = 11,
}
#[derive(Copy, Clone)]
#[repr(i32)]
#[derive(Debug)]
pub enum HAL_PIN_NAME {
    _PA_0 = 0,
    _PA_1 = 1,
    _PA_2 = 2,
    _PA_3 = 3,
    _PA_4 = 4,
    _PA_5 = 5,
    _PA_6 = 6,
    _PA_7 = 7,
    _PB_0 = 16,
    _PB_1 = 17,
    _PB_2 = 18,
    _PB_3 = 19,
    _PB_4 = 20,
    _PB_5 = 21,
    _PB_6 = 22,
    _PB_7 = 23,
    _PC_0 = 32,
    _PC_1 = 33,
    _PC_2 = 34,
    _PC_3 = 35,
    _PC_4 = 36,
    _PC_5 = 37,
    _PC_6 = 38,
    _PC_7 = 39,
    _PC_8 = 40,
    _PC_9 = 41,
    _PD_0 = 48,
    _PD_1 = 49,
    _PD_2 = 50,
    _PD_3 = 51,
    _PD_4 = 52,
    _PD_5 = 53,
    _PD_6 = 54,
    _PD_7 = 55,
    _PD_8 = 56,
    _PD_9 = 57,
    _PE_0 = 64,
    _PE_1 = 65,
    _PE_2 = 66,
    _PE_3 = 67,
    _PE_4 = 68,
    _PE_5 = 69,
    _PE_6 = 70,
    _PE_7 = 71,
    _PE_8 = 72,
    _PE_9 = 73,
    _PE_A = 74,
    _PF_0 = 80,
    _PF_1 = 81,
    _PF_2 = 82,
    _PF_3 = 83,
    _PF_4 = 84,
    _PF_5 = 85,
    _PG_0 = 96,
    _PG_1 = 97,
    _PG_2 = 98,
    _PG_3 = 99,
    _PG_4 = 100,
    _PG_5 = 101,
    _PG_6 = 102,
    _PG_7 = 103,
    _PH_0 = 112,
    _PH_1 = 113,
    _PH_2 = 114,
    _PH_3 = 115,
    _PH_4 = 116,
    _PH_5 = 117,
    _PH_6 = 118,
    _PH_7 = 119,
    _PI_0 = 128,
    _PI_1 = 129,
    _PI_2 = 130,
    _PI_3 = 131,
    _PI_4 = 132,
    _PI_5 = 133,
    _PI_6 = 134,
    _PI_7 = 135,
    _PJ_0 = 144,
    _PJ_1 = 145,
    _PJ_2 = 146,
    _PJ_3 = 147,
    _PJ_4 = 148,
    _PJ_5 = 149,
    _PJ_6 = 150,
    _PK_0 = 160,
    _PK_1 = 161,
    _PK_2 = 162,
    _PK_3 = 163,
    _PK_4 = 164,
    _PK_5 = 165,
    _PK_6 = 166,
    _PIN_NC = -1,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum HAL_GPIO_PIN_STATE {
    GPIO_PIN_LOW = 0,
    GPIO_PIN_HIGH = 1,
    GPIO_PIN_ERR = 2,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum HAL_GPIO_PIN_MODE {
    DIN_PULL_NONE = 0,
    DIN_PULL_LOW = 1,
    DIN_PULL_HIGH = 2,
    DOUT_PUSH_PULL = 3,
    DOUT_OPEN_DRAIN = 4,
    INT_LOW = 133,
    INT_HIGH = 134,
    INT_FALLING = 135,
    INT_RISING = 136,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed6 {
    GPIO_PORT_A = 0,
    GPIO_PORT_B = 1,
    GPIO_PORT_C = 2,
    GPIO_PORT_D = 3,
}
pub const hal_PullDefault: HAL_PinMode = HAL_PinMode::hal_PullNone;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum HAL_PinMode {
    hal_PullNone = 0,
    hal_PullUp = 1,
    hal_PullDown = 2,
    hal_OpenDrain = 3,
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _HAL_GPIO_PORT_ {
    pub out_data: uint32_t,
    pub in_data: uint32_t,
    pub dir: uint32_t,
}
impl ::core::default::Default for _HAL_GPIO_PORT_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type HAL_GPIO_PORT = _HAL_GPIO_PORT_;
pub type PHAL_GPIO_PORT = *mut _HAL_GPIO_PORT_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _HAL_GPIO_PIN_ {
    pub pin_mode: HAL_GPIO_PIN_MODE,
    pub pin_name: uint32_t,
}
impl ::core::default::Default for _HAL_GPIO_PIN_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type HAL_GPIO_PIN = _HAL_GPIO_PIN_;
pub type PHAL_GPIO_PIN = *mut _HAL_GPIO_PIN_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _HAL_GPIO_OP_ {
}
impl ::core::default::Default for _HAL_GPIO_OP_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type HAL_GPIO_OP = _HAL_GPIO_OP_;
pub type PHAL_GPIO_OP = *mut _HAL_GPIO_OP_;
pub type GPIO_IRQ_FUN =
    ::core::option::Option<unsafe extern "C" fn(Data: *mut ::ctypes::c_void,
                                                Id: uint32_t)>;
pub type GPIO_USER_IRQ_FUN =
    ::core::option::Option<extern "C" fn(Id: uint32_t)>;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _HAL_GPIO_ADAPTER_ {
    pub IrqHandle: IRQ_HANDLE,
    pub UserIrqHandler: GPIO_USER_IRQ_FUN,
    pub PortA_IrqHandler: [GPIO_IRQ_FUN; 32usize],
    pub PortA_IrqData: [*mut ::ctypes::c_void; 32usize],
    pub EnterCritical: ::core::option::Option<extern "C" fn()>,
    pub ExitCritical: ::core::option::Option<extern "C" fn()>,
    pub Local_Gpio_Dir: [uint32_t; 3usize],
    pub Gpio_Func_En: uint8_t,
    pub Locked: uint8_t,
}
impl ::core::default::Default for _HAL_GPIO_ADAPTER_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type HAL_GPIO_ADAPTER = _HAL_GPIO_ADAPTER_;
pub type PHAL_GPIO_ADAPTER = *mut _HAL_GPIO_ADAPTER_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed7 {
    HAL_GPIO_HIGHZ = 0,
    HAL_GPIO_PULL_LOW = 1,
    HAL_GPIO_PULL_HIGH = 2,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum GPIOMode_TypeDef {
    GPIO_Mode_IN = 0,
    GPIO_Mode_OUT = 1,
    GPIO_Mode_INT = 2,
    GPIO_Mode_MAX = 3,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum GPIOPuPd_TypeDef {
    GPIO_PuPd_NOPULL = 0,
    GPIO_PuPd_DOWN = 1,
    GPIO_PuPd_UP = 2,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum GPIOIT_LevelType {
    GPIO_INT_Trigger_LEVEL = 0,
    GPIO_INT_Trigger_EDGE = 1,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum GPIOIT_PolarityType {
    GPIO_INT_POLARITY_ACTIVE_LOW = 0,
    GPIO_INT_POLARITY_ACTIVE_HIGH = 1,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum GPIOIT_DebounceType {
    GPIO_INT_DEBOUNCE_DISABLE = 0,
    GPIO_INT_DEBOUNCE_ENABLE = 1,
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct GPIO_InitTypeDef {
    pub GPIO_Mode: GPIOMode_TypeDef,
    pub GPIO_PuPd: GPIOPuPd_TypeDef,
    pub GPIO_ITTrigger: GPIOIT_LevelType,
    pub GPIO_ITPolarity: GPIOIT_PolarityType,
    pub GPIO_ITDebounce: GPIOIT_DebounceType,
    pub GPIO_Pin: uint32_t,
}
impl ::core::default::Default for GPIO_InitTypeDef {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _SSI0_PINMUX_SELECT_ {
    SSI0_MUX_TO_GPIOE = 0,
    SSI0_MUX_TO_GPIOC = 1,
}
pub type SSI0_PINMUX_SELECT = _SSI0_PINMUX_SELECT_;
pub type PSSI0_PINMUX_SELECT = *mut _SSI0_PINMUX_SELECT_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _SSI1_PINMUX_SELECT_ {
    SSI1_MUX_TO_GPIOA = 0,
    SSI1_MUX_TO_GPIOB = 1,
    SSI1_MUX_TO_GPIOD = 2,
}
pub type SSI1_PINMUX_SELECT = _SSI1_PINMUX_SELECT_;
pub type PSSI1_PINMUX_SELECT = *mut _SSI1_PINMUX_SELECT_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _SSI2_PINMUX_SELECT_ {
    SSI2_MUX_TO_GPIOG = 0,
    SSI2_MUX_TO_GPIOE = 1,
    SSI2_MUX_TO_GPIOD = 2,
}
pub type SSI2_PINMUX_SELECT = _SSI2_PINMUX_SELECT_;
pub type PSSI2_PINMUX_SELECT = *mut _SSI2_PINMUX_SELECT_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _SSI0_MULTI_CS_PINMUX_SELECT_ {
    SSI0_CS_MUX_TO_GPIOE = 0,
    SSI0_CS_MUX_TO_GPIOC = 1,
}
pub type SSI0_MULTI_CS_PINMUX_SELECT = _SSI0_MULTI_CS_PINMUX_SELECT_;
pub type PSSI0_MULTI_CS_PINMUX_SELECT = *mut _SSI0_MULTI_CS_PINMUX_SELECT_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _SSI_CTRLR0_TMOD_ {
    TMOD_TR = 0,
    TMOD_TO = 1,
    TMOD_RO = 2,
    TMOD_EEPROM_R = 3,
}
pub type SSI_CTRLR0_TMOD = _SSI_CTRLR0_TMOD_;
pub type PSSI_CTRLR0_TMOD = *mut _SSI_CTRLR0_TMOD_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _SSI_CTRLR0_SCPOL_ {
    SCPOL_INACTIVE_IS_LOW = 0,
    SCPOL_INACTIVE_IS_HIGH = 1,
}
pub type SSI_CTRLR0_SCPOL = _SSI_CTRLR0_SCPOL_;
pub type PSSI_CTRLR0_SCPOL = *mut _SSI_CTRLR0_SCPOL_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _SSI_CTRLR0_SCPH_ {
    SCPH_TOGGLES_IN_MIDDLE = 0,
    SCPH_TOGGLES_AT_START = 1,
}
pub type SSI_CTRLR0_SCPH = _SSI_CTRLR0_SCPH_;
pub type PSSI_CTRLR0_SCPH = *mut _SSI_CTRLR0_SCPH_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _SSI_CTRLR0_DFS_ {
    DFS_4_BITS = 3,
    DFS_5_BITS = 4,
    DFS_6_BITS = 5,
    DFS_7_BITS = 6,
    DFS_8_BITS = 7,
    DFS_9_BITS = 8,
    DFS_10_BITS = 9,
    DFS_11_BITS = 10,
    DFS_12_BITS = 11,
    DFS_13_BITS = 12,
    DFS_14_BITS = 13,
    DFS_15_BITS = 14,
    DFS_16_BITS = 15,
}
pub type SSI_CTRLR0_DFS = _SSI_CTRLR0_DFS_;
pub type PSSI_CTRLR0_DFS = *mut _SSI_CTRLR0_DFS_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _SSI_CTRLR0_CFS_ {
    CFS_1_BIT = 0,
    CFS_2_BITS = 1,
    CFS_3_BITS = 2,
    CFS_4_BITS = 3,
    CFS_5_BITS = 4,
    CFS_6_BITS = 5,
    CFS_7_BITS = 6,
    CFS_8_BITS = 7,
    CFS_9_BITS = 8,
    CFS_10_BITS = 9,
    CFS_11_BITS = 10,
    CFS_12_BITS = 11,
    CFS_13_BITS = 12,
    CFS_14_BITS = 13,
    CFS_15_BITS = 14,
    CFS_16_BITS = 15,
}
pub type SSI_CTRLR0_CFS = _SSI_CTRLR0_CFS_;
pub type PSSI_CTRLR0_CFS = *mut _SSI_CTRLR0_CFS_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _SSI_CTRLR0_SLV_OE_ { SLV_TXD_ENABLE = 0, SLV_TXD_DISABLE = 1, }
pub type SSI_CTRLR0_SLV_OE = _SSI_CTRLR0_SLV_OE_;
pub type PSSI_CTRLR0_SLV_OE = *mut _SSI_CTRLR0_SLV_OE_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _SSI_ROLE_SELECT_ { SSI_SLAVE = 0, SSI_MASTER = 1, }
pub type SSI_ROLE_SELECT = _SSI_ROLE_SELECT_;
pub type PSSI_ROLE_SELECT = *mut _SSI_ROLE_SELECT_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _SSI_FRAME_FORMAT_ {
    FRF_MOTOROLA_SPI = 0,
    FRF_TI_SSP = 1,
    FRF_NS_MICROWIRE = 2,
    FRF_RSVD = 3,
}
pub type SSI_FRAME_FORMAT = _SSI_FRAME_FORMAT_;
pub type PSSI_FRAME_FORMAT = *mut _SSI_FRAME_FORMAT_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _SSI_DMACR_ENABLE_ {
    SSI_NODMA = 0,
    SSI_RXDMA_ENABLE = 1,
    SSI_TXDMA_ENABLE = 2,
    SSI_TRDMA_ENABLE = 3,
}
pub type SSI_DMACR_ENABLE = _SSI_DMACR_ENABLE_;
pub type PSSI_DMACR_ENABLE = *mut _SSI_DMACR_ENABLE_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _SSI_MWCR_HANDSHAKE_ {
    MW_HANDSHAKE_DISABLE = 0,
    MW_HANDSHAKE_ENABLE = 1,
}
pub type SSI_MWCR_HANDSHAKE = _SSI_MWCR_HANDSHAKE_;
pub type PSSI_MWCR_HANDSHAKE = *mut _SSI_MWCR_HANDSHAKE_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _SSI_MWCR_DIRECTION_ {
    MW_DIRECTION_SLAVE_TO_MASTER = 0,
    MW_DIRECTION_MASTER_TO_SLAVE = 1,
}
pub type SSI_MWCR_DIRECTION = _SSI_MWCR_DIRECTION_;
pub type PSSI_MWCR_DIRECTION = *mut _SSI_MWCR_DIRECTION_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _SSI_MWCR_TMOD_ {
    MW_TMOD_NONSEQUENTIAL = 0,
    MW_TMOD_SEQUENTIAL = 1,
}
pub type SSI_MWCR_TMOD = _SSI_MWCR_TMOD_;
pub type PSSI_MWCR_TMOD = *mut _SSI_MWCR_TMOD_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _SSI_DATA_TRANSFER_MECHANISM_ {
    SSI_DTM_BASIC = 0,
    SSI_DTM_INTERRUPT = 1,
    SSI_DTM_DMA = 2,
}
pub type SSI_DATA_TRANSFER_MECHANISM = _SSI_DATA_TRANSFER_MECHANISM_;
pub type PSSI_DATA_TRANSFER_MECHANISM = *mut _SSI_DATA_TRANSFER_MECHANISM_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _SSI_DBG_TYPE_LIST_ {
    DBG_TYPE_ENTRANCE = 1,
    DBG_TYPE_INIT = 2,
    DBG_TYPE_INIT_V = 4,
    DBG_TYPE_INIT_VV = 8,
    DBG_TYPE_PINMUX = 16,
    DBG_TYPE_ENDIS = 32,
    DBG_TYPE_INT = 64,
    DBG_TYPE_INT_V = 128,
    DBG_TYPE_INT_HNDLR = 256,
    DBG_TYPE_INT_READ = 512,
    DBG_TYPE_INT_WRITE = 1024,
    DBG_TYPE_STATUS = 2048,
    DBG_TYPE_FIFO = 4096,
    DBG_TYPE_READ = 8192,
    DBG_TYPE_WRITE = 16384,
    DBG_TYPE_SLV_CTRL = 32768,
}
pub type SSI_DBG_TYPE_LIST = _SSI_DBG_TYPE_LIST_;
pub type PSSI_DBG_TYPE_LIST = *mut _SSI_DBG_TYPE_LIST_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _SSI_DMA_CONFIG_ {
    pub pHalGdmaOp: *mut ::ctypes::c_void,
    pub pTxHalGdmaAdapter: *mut ::ctypes::c_void,
    pub pRxHalGdmaAdapter: *mut ::ctypes::c_void,
    pub RxDmaBurstSize: uint8_t,
    pub TxDmaBurstSize: uint8_t,
    pub RxDmaEnable: uint8_t,
    pub TxDmaEnable: uint8_t,
    pub RxGdmaIrqHandle: IRQ_HANDLE,
    pub TxGdmaIrqHandle: IRQ_HANDLE,
}
impl ::core::default::Default for _SSI_DMA_CONFIG_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type SSI_DMA_CONFIG = _SSI_DMA_CONFIG_;
pub type PSSI_DMA_CONFIG = *mut _SSI_DMA_CONFIG_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _HAL_SSI_DMA_MULTIBLK_ {
    pub GdmaChLli: [GDMA_CH_LLI_ELE; 16usize],
    pub Lli: [GDMA_CH_LLI; 16usize],
    pub BlockSizeList: [BLOCK_SIZE_LIST; 16usize],
}
impl ::core::default::Default for _HAL_SSI_DMA_MULTIBLK_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type SSI_DMA_MULTIBLK = _HAL_SSI_DMA_MULTIBLK_;
pub type PSSI_DMA_MULTIBLK = *mut _HAL_SSI_DMA_MULTIBLK_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _HAL_SSI_ADAPTOR_ {
    pub DmaConfig: SSI_DMA_CONFIG,
    pub IrqHandle: IRQ_HANDLE,
    pub RxCompCallback: ::core::option::Option<unsafe extern "C" fn(Para:
                                                                        *mut ::ctypes::c_void)>,
    pub RxCompCbPara: *mut ::ctypes::c_void,
    pub RxData: *mut ::ctypes::c_void,
    pub TxCompCallback: ::core::option::Option<unsafe extern "C" fn(Para:
                                                                        *mut ::ctypes::c_void)>,
    pub TxCompCbPara: *mut ::ctypes::c_void,
    pub TxData: *mut ::ctypes::c_void,
    pub DmaRxDataLevel: uint32_t,
    pub DmaTxDataLevel: uint32_t,
    pub InterruptPriority: uint32_t,
    pub RxLength: uint32_t,
    pub RxLengthRemainder: uint32_t,
    pub RxThresholdLevel: uint32_t,
    pub TxLength: uint32_t,
    pub TxThresholdLevel: uint32_t,
    pub SlaveSelectEnable: uint32_t,
    pub ClockDivider: uint16_t,
    pub DataFrameNumber: uint16_t,
    pub ControlFrameSize: uint8_t,
    pub DataFrameFormat: uint8_t,
    pub DataFrameSize: uint8_t,
    pub DmaControl: uint8_t,
    pub Index: uint8_t,
    pub InterruptMask: uint8_t,
    pub MicrowireDirection: uint8_t,
    pub MicrowireHandshaking: uint8_t,
    pub MicrowireTransferMode: uint8_t,
    pub PinmuxSelect: uint8_t,
    pub Role: uint8_t,
    pub SclkPhase: uint8_t,
    pub SclkPolarity: uint8_t,
    pub SlaveOutputEnable: uint8_t,
    pub TransferMode: uint8_t,
    pub TransferMechanism: uint8_t,
    pub Reserve: uint8_t,
    pub HaveTxChannel: uint8_t,
    pub HaveRxChannel: uint8_t,
    pub DefaultRxThresholdLevel: uint8_t,
    pub DmaTxMultiBlk: SSI_DMA_MULTIBLK,
    pub DmaRxMultiBlk: SSI_DMA_MULTIBLK,
    pub ReservedDummy: uint32_t,
    pub TxIdleCallback: ::core::option::Option<unsafe extern "C" fn(Para:
                                                                        *mut ::ctypes::c_void)>,
    pub TxIdleCbPara: *mut ::ctypes::c_void,
}
impl ::core::default::Default for _HAL_SSI_ADAPTOR_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type HAL_SSI_ADAPTOR = _HAL_SSI_ADAPTOR_;
pub type PHAL_SSI_ADAPTOR = *mut _HAL_SSI_ADAPTOR_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _HAL_SSI_OP_ {
    pub HalSsiPinmuxEnable: ::core::option::Option<unsafe extern "C" fn(Adaptor:
                                                                            *mut ::ctypes::c_void)
                                                       -> HAL_Status>,
    pub HalSsiPinmuxDisable: ::core::option::Option<unsafe extern "C" fn(Adaptor:
                                                                             *mut ::ctypes::c_void)
                                                        -> HAL_Status>,
    pub HalSsiEnable: ::core::option::Option<unsafe extern "C" fn(Adaptor:
                                                                      *mut ::ctypes::c_void)
                                                 -> HAL_Status>,
    pub HalSsiDisable: ::core::option::Option<unsafe extern "C" fn(Adaptor:
                                                                       *mut ::ctypes::c_void)
                                                  -> HAL_Status>,
    pub HalSsiInit: ::core::option::Option<unsafe extern "C" fn(Adaptor:
                                                                    *mut ::ctypes::c_void)
                                               -> HAL_Status>,
    pub HalSsiSetSclkPolarity: ::core::option::Option<unsafe extern "C" fn(Adaptor:
                                                                               *mut ::ctypes::c_void)
                                                          -> HAL_Status>,
    pub HalSsiSetSclkPhase: ::core::option::Option<unsafe extern "C" fn(Adaptor:
                                                                            *mut ::ctypes::c_void)
                                                       -> HAL_Status>,
    pub HalSsiWrite: ::core::option::Option<unsafe extern "C" fn(Adaptor:
                                                                     *mut ::ctypes::c_void,
                                                                 value:
                                                                     uint32_t)
                                                -> HAL_Status>,
    pub HalSsiLoadSetting: ::core::option::Option<unsafe extern "C" fn(Adaptor:
                                                                           *mut ::ctypes::c_void,
                                                                       Setting:
                                                                           *mut ::ctypes::c_void)
                                                      -> HAL_Status>,
    pub HalSsiSetInterruptMask: ::core::option::Option<unsafe extern "C" fn(Adaptor:
                                                                                *mut ::ctypes::c_void)
                                                           -> HAL_Status>,
    pub HalSsiSetDeviceRole: ::core::option::Option<unsafe extern "C" fn(Adaptor:
                                                                             *mut ::ctypes::c_void,
                                                                         Role:
                                                                             uint32_t)
                                                        -> HAL_Status>,
    pub HalSsiInterruptEnable: ::core::option::Option<unsafe extern "C" fn(Adaptor:
                                                                               *mut ::ctypes::c_void)
                                                          -> HAL_Status>,
    pub HalSsiInterruptDisable: ::core::option::Option<unsafe extern "C" fn(Adaptor:
                                                                                *mut ::ctypes::c_void)
                                                           -> HAL_Status>,
    pub HalSsiReadInterrupt: ::core::option::Option<unsafe extern "C" fn(Adaptor:
                                                                             *mut ::ctypes::c_void,
                                                                         RxData:
                                                                             *mut ::ctypes::c_void,
                                                                         Length:
                                                                             uint32_t)
                                                        -> HAL_Status>,
    pub HalSsiSetRxFifoThresholdLevel: ::core::option::Option<unsafe extern "C" fn(Adaptor:
                                                                                       *mut ::ctypes::c_void)
                                                                  ->
                                                                      HAL_Status>,
    pub HalSsiSetTxFifoThresholdLevel: ::core::option::Option<unsafe extern "C" fn(Adaptor:
                                                                                       *mut ::ctypes::c_void)
                                                                  ->
                                                                      HAL_Status>,
    pub HalSsiWriteInterrupt: ::core::option::Option<unsafe extern "C" fn(Adaptor:
                                                                              *mut ::ctypes::c_void,
                                                                          TxData:
                                                                              *mut uint8_t,
                                                                          Length:
                                                                              uint32_t)
                                                         -> HAL_Status>,
    pub HalSsiSetSlaveEnableRegister: ::core::option::Option<unsafe extern "C" fn(Adaptor:
                                                                                      *mut ::ctypes::c_void,
                                                                                  SlaveIndex:
                                                                                      uint32_t)
                                                                 ->
                                                                     HAL_Status>,
    pub HalSsiBusy: ::core::option::Option<unsafe extern "C" fn(Adaptor:
                                                                    *mut ::ctypes::c_void)
                                               -> uint32_t>,
    pub HalSsiReadable: ::core::option::Option<unsafe extern "C" fn(Adaptor:
                                                                        *mut ::ctypes::c_void)
                                                   -> uint32_t>,
    pub HalSsiWriteable: ::core::option::Option<unsafe extern "C" fn(Adaptor:
                                                                         *mut ::ctypes::c_void)
                                                    -> uint32_t>,
    pub HalSsiGetInterruptMask: ::core::option::Option<unsafe extern "C" fn(Adaptor:
                                                                                *mut ::ctypes::c_void)
                                                           -> uint32_t>,
    pub HalSsiGetRxFifoLevel: ::core::option::Option<unsafe extern "C" fn(Adaptor:
                                                                              *mut ::ctypes::c_void)
                                                         -> uint32_t>,
    pub HalSsiGetTxFifoLevel: ::core::option::Option<unsafe extern "C" fn(Adaptor:
                                                                              *mut ::ctypes::c_void)
                                                         -> uint32_t>,
    pub HalSsiGetStatus: ::core::option::Option<unsafe extern "C" fn(Adaptor:
                                                                         *mut ::ctypes::c_void)
                                                    -> uint32_t>,
    pub HalSsiGetInterruptStatus: ::core::option::Option<unsafe extern "C" fn(Adaptor:
                                                                                  *mut ::ctypes::c_void)
                                                             -> uint32_t>,
    pub HalSsiRead: ::core::option::Option<unsafe extern "C" fn(Adaptor:
                                                                    *mut ::ctypes::c_void)
                                               -> uint32_t>,
    pub HalSsiGetRawInterruptStatus: ::core::option::Option<unsafe extern "C" fn(Adaptor:
                                                                                     *mut ::ctypes::c_void)
                                                                -> uint32_t>,
    pub HalSsiGetSlaveEnableRegister: ::core::option::Option<unsafe extern "C" fn(Adaptor:
                                                                                      *mut ::ctypes::c_void)
                                                                 -> uint32_t>,
}
impl ::core::default::Default for _HAL_SSI_OP_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type HAL_SSI_OP = _HAL_SSI_OP_;
pub type PHAL_SSI_OP = *mut _HAL_SSI_OP_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _DW_SSI_DEFAULT_SETTING_ {
    pub RxCompCallback: ::core::option::Option<unsafe extern "C" fn(Para:
                                                                        *mut ::ctypes::c_void)>,
    pub RxCompCbPara: *mut ::ctypes::c_void,
    pub RxData: *mut ::ctypes::c_void,
    pub TxCompCallback: ::core::option::Option<unsafe extern "C" fn(Para:
                                                                        *mut ::ctypes::c_void)>,
    pub TxCompCbPara: *mut ::ctypes::c_void,
    pub TxData: *mut ::ctypes::c_void,
    pub DmaRxDataLevel: uint32_t,
    pub DmaTxDataLevel: uint32_t,
    pub InterruptPriority: uint32_t,
    pub RxLength: uint32_t,
    pub RxLengthRemainder: uint32_t,
    pub RxThresholdLevel: uint32_t,
    pub TxLength: uint32_t,
    pub TxThresholdLevel: uint32_t,
    pub SlaveSelectEnable: uint32_t,
    pub ClockDivider: uint16_t,
    pub DataFrameNumber: uint16_t,
    pub ControlFrameSize: uint8_t,
    pub DataFrameFormat: uint8_t,
    pub DataFrameSize: uint8_t,
    pub DmaControl: uint8_t,
    pub InterruptMask: uint8_t,
    pub MicrowireDirection: uint8_t,
    pub MicrowireHandshaking: uint8_t,
    pub MicrowireTransferMode: uint8_t,
    pub SclkPhase: uint8_t,
    pub SclkPolarity: uint8_t,
    pub SlaveOutputEnable: uint8_t,
    pub TransferMode: uint8_t,
    pub TransferMechanism: uint8_t,
}
impl ::core::default::Default for _DW_SSI_DEFAULT_SETTING_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type DW_SSI_DEFAULT_SETTING = _DW_SSI_DEFAULT_SETTING_;
pub type PDW_SSI_DEFAULT_SETTING = *mut _DW_SSI_DEFAULT_SETTING_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct spi_s {
    pub spi_adp: HAL_SSI_ADAPTOR,
    pub spi_op: HAL_SSI_OP,
    pub irq_handler: uint32_t,
    pub irq_id: uint32_t,
    pub dma_en: uint32_t,
    pub state: uint32_t,
    pub sclk: uint8_t,
    pub spi_gdma_adp_tx: HAL_GDMA_ADAPTER,
    pub spi_gdma_adp_rx: HAL_GDMA_ADAPTER,
    pub bus_tx_done_handler: uint32_t,
    pub bus_tx_done_irq_id: uint32_t,
}
impl ::core::default::Default for spi_s {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _RUART_SPEED_SETTING_ {
    pub BaudRate: uint32_t,
    pub Ovsr: uint32_t,
    pub Div: uint32_t,
    pub Ovsr_adj: uint32_t,
    pub Ovsr_adj_max_bits: uint8_t,
    pub Ovsr_adj_bits: uint8_t,
    pub Ovsr_adj_map: *mut uint16_t,
    pub max_err: uint32_t,
    pub Ovsr_min: uint32_t,
    pub Ovsr_max: uint32_t,
    pub divisor_resolution: uint32_t,
    pub jitter_lim: uint32_t,
    pub sclk: uint32_t,
}
impl ::core::default::Default for _RUART_SPEED_SETTING_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type RUART_SPEED_SETTING = _RUART_SPEED_SETTING_;
pub type PRUART_SPEED_SETTING = *mut _RUART_SPEED_SETTING_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _UART_RXFIFO_TRIGGER_LEVEL_ {
    OneByte = 0,
    FourBytes = 1,
    EightBytes = 16,
    FourteenBytes = 17,
}
pub type UART_RXFIFO_TRIGGER_LEVEL = _UART_RXFIFO_TRIGGER_LEVEL_;
pub type PUART_RXFIFO_TRIGGER_LEVEL = *mut _UART_RXFIFO_TRIGGER_LEVEL_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _RUART0_PINMUX_SELECT_ {
    RUART0_MUX_TO_GPIOC = 0,
    RUART0_MUX_TO_GPIOE = 1,
    RUART0_MUX_TO_GPIOA = 2,
}
pub type RUART0_PINMUX_SELECT = _RUART0_PINMUX_SELECT_;
pub type PRUART0_PINMUX_SELECT = *mut _RUART0_PINMUX_SELECT_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _RUART1_PINMUX_SELECT_ {
    RUART1_MUX_TO_GPIOD = 0,
    RUART1_MUX_TO_GPIOE = 1,
    RUART1_MUX_TO_GPIOB = 2,
}
pub type RUART1_PINMUX_SELECT = _RUART1_PINMUX_SELECT_;
pub type PRUART1_PINMUX_SELECT = *mut _RUART1_PINMUX_SELECT_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _RUART2_PINMUX_SELECT_ {
    RUART2_MUX_TO_GPIOA = 0,
    RUART2_MUX_TO_GPIOC = 1,
    RUART2_MUX_TO_GPIOD = 2,
}
pub type RUART2_PINMUX_SELECT = _RUART2_PINMUX_SELECT_;
pub type PRUART2_PINMUX_SELECT = *mut _RUART2_PINMUX_SELECT_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _RUART_FLOW_CONTROL_ { AUTOFLOW_DISABLE = 0, AUTOFLOW_ENABLE = 1, }
pub type RUART_FLOW_CONTROL = _RUART_FLOW_CONTROL_;
pub type PRUART_FLOW_CONTROL = *mut _RUART_FLOW_CONTROL_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _RUART_WORD_LEN_SEL_ { RUART_WLS_7BITS = 0, RUART_WLS_8BITS = 1, }
pub type RUART_WORD_LEN_SEL = _RUART_WORD_LEN_SEL_;
pub type PRUART_WORD_LEN_SEL = *mut _RUART_WORD_LEN_SEL_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _RUART_STOP_BITS_ { RUART_STOP_BIT_1 = 0, RUART_STOP_BIT_2 = 1, }
pub type RUART_STOP_BITS = _RUART_STOP_BITS_;
pub type PRUART_STOP_BITS = *mut _RUART_STOP_BITS_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _RUART_PARITY_CONTROL_ {
    RUART_PARITY_DISABLE = 0,
    RUART_PARITY_ENABLE = 1,
}
pub type RUART_PARITY_CONTROL = _RUART_PARITY_CONTROL_;
pub type PRUART_PARITY_CONTROL = *mut _RUART_PARITY_CONTROL_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _RUART_PARITY_TYPE_ { RUART_ODD_PARITY = 0, RUART_EVEN_PARITY = 1, }
pub type RUART_PARITY_TYPE = _RUART_PARITY_TYPE_;
pub type PRUART_PARITY_TYPE = *mut _RUART_PARITY_TYPE_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _RUART_STICK_PARITY_CONTROL_ {
    RUART_STICK_PARITY_DISABLE = 0,
    RUART_STICK_PARITY_ENABLE = 1,
}
pub type RUART_STICK_PARITY_CONTROL = _RUART_STICK_PARITY_CONTROL_;
pub type PRUART_STICK_PARITY_CONTROL = *mut _RUART_STICK_PARITY_CONTROL_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _UART_INT_ID_ {
    ModemStatus = 0,
    TxFifoEmpty = 1,
    ReceiverDataAvailable = 2,
    ReceivLineStatus = 3,
    TimeoutIndication = 6,
}
pub type UART_INT_ID = _UART_INT_ID_;
pub type PUART_INT_ID = *mut _UART_INT_ID_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _HAL_UART_State_ {
    HAL_UART_STATE_NULL = 0,
    HAL_UART_STATE_READY = 16,
    HAL_UART_STATE_BUSY = 32,
    HAL_UART_STATE_BUSY_TX = 33,
    HAL_UART_STATE_BUSY_RX = 34,
    HAL_UART_STATE_BUSY_TX_RX = 35,
    HAL_UART_STATE_TIMEOUT = 48,
    HAL_UART_STATE_ERROR = 64,
}
pub type HAL_UART_State = _HAL_UART_State_;
pub type PHAL_UART_State = *mut _HAL_UART_State_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _HAL_UART_Status_ {
    HAL_UART_STATUS_OK = 0,
    HAL_UART_STATUS_TIMEOUT = 1,
    HAL_UART_STATUS_ERR_OVERRUN = 2,
    HAL_UART_STATUS_ERR_PARITY = 4,
    HAL_UART_STATUS_ERR_FRAM = 8,
    HAL_UART_STATUS_ERR_BREAK = 16,
    HAL_UART_STATUS_ERR_PARA = 32,
    HAL_UART_STATUS_ERR_RXFIFO = 128,
}
pub type HAL_UART_Status = _HAL_UART_Status_;
pub type PHAL_UART_Status = *mut _HAL_UART_Status_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _HAL_UART_DMA_MULTIBLK_ {
    pub GdmaChLli: [GDMA_CH_LLI_ELE; 16usize],
    pub Lli: [GDMA_CH_LLI; 16usize],
    pub BlockSizeList: [BLOCK_SIZE_LIST; 16usize],
}
impl ::core::default::Default for _HAL_UART_DMA_MULTIBLK_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type UART_DMA_MULTIBLK = _HAL_UART_DMA_MULTIBLK_;
pub type PUART_DMA_MULTIBLK = *mut _HAL_UART_DMA_MULTIBLK_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _UART_DMA_CONFIG_ {
    pub TxDmaEnable: uint8_t,
    pub RxDmaEnable: uint8_t,
    pub TxDmaBurstSize: uint8_t,
    pub RxDmaBurstSize: uint8_t,
    pub pHalGdmaOp: *mut ::ctypes::c_void,
    pub pTxHalGdmaAdapter: *mut ::ctypes::c_void,
    pub pRxHalGdmaAdapter: *mut ::ctypes::c_void,
    pub TxGdmaIrqHandle: IRQ_HANDLE,
    pub RxGdmaIrqHandle: IRQ_HANDLE,
    pub pTxDmaBlkList: *mut UART_DMA_MULTIBLK,
    pub pRxDmaBlkList: *mut UART_DMA_MULTIBLK,
    pub TxDmaMBChnl: uint8_t,
    pub RxDmaMBChnl: uint8_t,
}
impl ::core::default::Default for _UART_DMA_CONFIG_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type UART_DMA_CONFIG = _UART_DMA_CONFIG_;
pub type PUART_DMA_CONFIG = *mut _UART_DMA_CONFIG_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _HAL_RUART_ADAPTER_ {
    pub BaudRate: uint32_t,
    pub FlowControl: uint32_t,
    pub FifoControl: uint32_t,
    pub Interrupts: uint32_t,
    pub TxCount: uint32_t,
    pub RxCount: uint32_t,
    pub pTxBuf: *mut uint8_t,
    pub pRxBuf: *mut uint8_t,
    pub State: HAL_UART_State,
    pub Status: uint8_t,
    pub Locked: uint8_t,
    pub UartIndex: uint8_t,
    pub WordLen: uint8_t,
    pub StopBit: uint8_t,
    pub Parity: uint8_t,
    pub ParityType: uint8_t,
    pub StickParity: uint8_t,
    pub ModemStatus: uint8_t,
    pub DmaEnable: uint8_t,
    pub TestCaseNumber: uint8_t,
    pub PinmuxSelect: uint8_t,
    pub PullMode: BOOL,
    pub IrqHandle: IRQ_HANDLE,
    pub DmaConfig: PUART_DMA_CONFIG,
    pub ModemStatusInd: ::core::option::Option<unsafe extern "C" fn(pAdapter:
                                                                        *mut ::ctypes::c_void)>,
    pub TxTDCallback: ::core::option::Option<unsafe extern "C" fn(pAdapter:
                                                                      *mut ::ctypes::c_void)>,
    pub RxDRCallback: ::core::option::Option<unsafe extern "C" fn(pAdapter:
                                                                      *mut ::ctypes::c_void)>,
    pub TxCompCallback: ::core::option::Option<unsafe extern "C" fn(para:
                                                                        *mut ::ctypes::c_void)>,
    pub RxCompCallback: ::core::option::Option<unsafe extern "C" fn(para:
                                                                        *mut ::ctypes::c_void)>,
    pub TxTDCbPara: *mut ::ctypes::c_void,
    pub RxDRCbPara: *mut ::ctypes::c_void,
    pub TxCompCbPara: *mut ::ctypes::c_void,
    pub RxCompCbPara: *mut ::ctypes::c_void,
    pub EnterCritical: ::core::option::Option<extern "C" fn()>,
    pub ExitCritical: ::core::option::Option<extern "C" fn()>,
    pub pDefaultBaudRateTbl: *mut uint32_t,
    pub pDefaultOvsrRTbl: *mut uint8_t,
    pub pDefaultDivTbl: *mut uint16_t,
    pub pDefOvsrAdjBitTbl_10: *mut uint8_t,
    pub pDefOvsrAdjBitTbl_9: *mut uint8_t,
    pub pDefOvsrAdjBitTbl_8: *mut uint8_t,
    pub pDefOvsrAdjTbl_10: *mut uint16_t,
    pub pDefOvsrAdjTbl_9: *mut uint16_t,
    pub pDefOvsrAdjTbl_8: *mut uint16_t,
    pub pTxDMAMBlk: PUART_DMA_MULTIBLK,
    pub pRxDMAMBlk: PUART_DMA_MULTIBLK,
    pub BaudRateUsing: uint32_t,
    pub WordLenUsing: uint8_t,
    pub ParityUsing: uint8_t,
    pub RTSCtrl: uint8_t,
}
impl ::core::default::Default for _HAL_RUART_ADAPTER_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type HAL_RUART_ADAPTER = _HAL_RUART_ADAPTER_;
pub type PHAL_RUART_ADAPTER = *mut _HAL_RUART_ADAPTER_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _HAL_RUART_OP_ {
    pub HalRuartAdapterLoadDef: ::core::option::Option<unsafe extern "C" fn(pAdp:
                                                                                *mut ::ctypes::c_void,
                                                                            UartIdx:
                                                                                uint8_t)>,
    pub HalRuartTxGdmaLoadDef: ::core::option::Option<unsafe extern "C" fn(pAdp:
                                                                               *mut ::ctypes::c_void,
                                                                           pCfg:
                                                                               *mut ::ctypes::c_void)>,
    pub HalRuartRxGdmaLoadDef: ::core::option::Option<unsafe extern "C" fn(pAdp:
                                                                               *mut ::ctypes::c_void,
                                                                           pCfg:
                                                                               *mut ::ctypes::c_void)>,
    pub HalRuartResetRxFifo: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                             *mut ::ctypes::c_void)
                                                        -> HAL_Status>,
    pub HalRuartInit: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                      *mut ::ctypes::c_void)
                                                 -> HAL_Status>,
    pub HalRuartDeInit: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                        *mut ::ctypes::c_void)>,
    pub HalRuartPutC: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                      *mut ::ctypes::c_void,
                                                                  TxData:
                                                                      uint8_t)
                                                 -> HAL_Status>,
    pub HalRuartSend: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                      *mut ::ctypes::c_void,
                                                                  pTxData:
                                                                      *mut uint8_t,
                                                                  Length:
                                                                      uint32_t,
                                                                  Timeout:
                                                                      uint32_t)
                                                 -> uint32_t>,
    pub HalRuartIntSend: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                         *mut ::ctypes::c_void,
                                                                     pTxData:
                                                                         *mut uint8_t,
                                                                     Length:
                                                                         uint32_t)
                                                    -> HAL_Status>,
    pub HalRuartDmaSend: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                         *mut ::ctypes::c_void,
                                                                     pTxData:
                                                                         *mut uint8_t,
                                                                     Length:
                                                                         uint32_t)
                                                    -> HAL_Status>,
    pub HalRuartStopSend: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                          *mut ::ctypes::c_void)
                                                     -> HAL_Status>,
    pub HalRuartGetC: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                      *mut ::ctypes::c_void,
                                                                  pRxByte:
                                                                      *mut uint8_t)
                                                 -> HAL_Status>,
    pub HalRuartRecv: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                      *mut ::ctypes::c_void,
                                                                  pRxData:
                                                                      *mut uint8_t,
                                                                  Length:
                                                                      uint32_t,
                                                                  Timeout:
                                                                      uint32_t)
                                                 -> uint32_t>,
    pub HalRuartIntRecv: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                         *mut ::ctypes::c_void,
                                                                     pRxData:
                                                                         *mut uint8_t,
                                                                     Length:
                                                                         uint32_t)
                                                    -> HAL_Status>,
    pub HalRuartDmaRecv: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                         *mut ::ctypes::c_void,
                                                                     pRxData:
                                                                         *mut uint8_t,
                                                                     Length:
                                                                         uint32_t)
                                                    -> HAL_Status>,
    pub HalRuartStopRecv: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                          *mut ::ctypes::c_void)
                                                     -> HAL_Status>,
    pub HalRuartGetIMR: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                        *mut ::ctypes::c_void)
                                                   -> uint8_t>,
    pub HalRuartSetIMR: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                        *mut ::ctypes::c_void)>,
    pub HalRuartGetDebugValue: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                               *mut ::ctypes::c_void,
                                                                           DbgSel:
                                                                               uint32_t)
                                                          -> uint32_t>,
    pub HalRuartDmaInit: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                         *mut ::ctypes::c_void)>,
    pub HalRuartRTSCtrl: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                         *mut ::ctypes::c_void,
                                                                     RtsCtrl:
                                                                         BOOLEAN)>,
    pub HalRuartRegIrq: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                        *mut ::ctypes::c_void)>,
    pub HalRuartIntEnable: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                           *mut ::ctypes::c_void)>,
    pub HalRuartIntDisable: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                            *mut ::ctypes::c_void)>,
}
impl ::core::default::Default for _HAL_RUART_OP_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type HAL_RUART_OP = _HAL_RUART_OP_;
pub type PHAL_RUART_OP = *mut _HAL_RUART_OP_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _RUART_DATA_ {
    pub pHalRuartAdapter: PHAL_RUART_ADAPTER,
    pub PullMode: BOOL,
    pub BinaryData: uint8_t,
    pub SendBuffer: uint8_t,
    pub RecvBuffer: uint8_t,
}
impl ::core::default::Default for _RUART_DATA_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type RUART_DATA = _RUART_DATA_;
pub type PRUART_DATA = *mut _RUART_DATA_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _RUART_ADAPTER_ {
    pub pHalRuartOp: PHAL_RUART_OP,
    pub pHalRuartAdapter: PHAL_RUART_ADAPTER,
    pub pHalRuartDmaCfg: PUART_DMA_CONFIG,
}
impl ::core::default::Default for _RUART_ADAPTER_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type RUART_ADAPTER = _RUART_ADAPTER_;
pub type PRUART_ADAPTER = *mut _RUART_ADAPTER_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _I2C_ADDR_MODE_ { I2C_ADDR_7BIT = 0, I2C_ADDR_10BIT = 1, }
pub type I2C_ADDR_MODE = _I2C_ADDR_MODE_;
pub type PI2C_ADDR_MODE = *mut _I2C_ADDR_MODE_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _I2C_SPD_MODE_ { I2C_SS_MODE = 1, I2C_FS_MODE = 2, I2C_HS_MODE = 3, }
pub type I2C_SPD_MODE = _I2C_SPD_MODE_;
pub type PI2C_SPD_MODE = *mut _I2C_SPD_MODE_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _I2C_DBG_LVL_ { HAL_I2C_LVL = 1, SAL_I2C_LVL = 2, VERI_I2C_LVL = 3, }
pub type I2C_DBG_LVL = _I2C_DBG_LVL_;
pub type PI2C_DBG_LVL = *mut _I2C_DBG_LVL_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _I2C_MODULE_SEL_ {
    I2C0_SEL = 0,
    I2C1_SEL = 1,
    I2C2_SEL = 2,
    I2C3_SEL = 3,
}
pub type I2C_MODULE_SEL = _I2C_MODULE_SEL_;
pub type PI2C_MODULE_SEL = *mut _I2C_MODULE_SEL_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _HAL_I2C_INIT_DAT_ {
    pub I2CIdx: uint8_t,
    pub I2CEn: uint8_t,
    pub I2CMaster: uint8_t,
    pub I2CAddrMod: uint8_t,
    pub I2CSpdMod: uint8_t,
    pub I2CSetup: uint8_t,
    pub I2CRXTL: uint8_t,
    pub I2CTXTL: uint8_t,
    pub I2CBusLd: uint8_t,
    pub I2CReSTR: uint8_t,
    pub I2CGC: uint8_t,
    pub I2CStartB: uint8_t,
    pub I2CSlvNoAck: uint8_t,
    pub I2CDMACtrl: uint8_t,
    pub I2CCmd: uint8_t,
    pub I2CDataLen: uint8_t,
    pub I2CSlvAckGC: uint8_t,
    pub I2CStop: uint8_t,
    pub RSVD0: uint16_t,
    pub I2CRWData: *mut uint8_t,
    pub I2CIntrMSK: uint16_t,
    pub I2CIntrClr: uint16_t,
    pub I2CAckAddr: uint16_t,
    pub I2CSdaHd: uint16_t,
    pub I2CClk: uint32_t,
    pub I2CTxDMARqLv: uint8_t,
    pub I2CRxDMARqLv: uint8_t,
    pub RSVD1: uint16_t,
}
impl ::core::default::Default for _HAL_I2C_INIT_DAT_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type HAL_I2C_INIT_DAT = _HAL_I2C_INIT_DAT_;
pub type PHAL_I2C_INIT_DAT = *mut _HAL_I2C_INIT_DAT_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _HAL_I2C_OP_ {
    pub HalI2CInit: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                    *mut ::ctypes::c_void)
                                               -> HAL_Status>,
    pub HalI2CDeInit: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                      *mut ::ctypes::c_void)
                                                 -> HAL_Status>,
    pub HalI2CSend: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                    *mut ::ctypes::c_void)
                                               -> HAL_Status>,
    pub HalI2CReceive: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                       *mut ::ctypes::c_void)
                                                  -> uint8_t>,
    pub HalI2CEnable: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                      *mut ::ctypes::c_void)
                                                 -> HAL_Status>,
    pub HalI2CIntrCtrl: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                        *mut ::ctypes::c_void)
                                                   -> HAL_Status>,
    pub HalI2CReadReg: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                       *mut ::ctypes::c_void,
                                                                   I2CReg:
                                                                       uint8_t)
                                                  -> uint32_t>,
    pub HalI2CWriteReg: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                        *mut ::ctypes::c_void,
                                                                    I2CReg:
                                                                        uint8_t,
                                                                    RegVal:
                                                                        uint32_t)
                                                   -> HAL_Status>,
    pub HalI2CSetCLK: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                      *mut ::ctypes::c_void)
                                                 -> HAL_Status>,
    pub HalI2CMassSend: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                        *mut ::ctypes::c_void)
                                                   -> HAL_Status>,
    pub HalI2CClrIntr: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                       *mut ::ctypes::c_void)
                                                  -> HAL_Status>,
    pub HalI2CClrAllIntr: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                          *mut ::ctypes::c_void)
                                                     -> HAL_Status>,
    pub HalI2CDMACtrl: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                       *mut ::ctypes::c_void)
                                                  -> HAL_Status>,
}
impl ::core::default::Default for _HAL_I2C_OP_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type HAL_I2C_OP = _HAL_I2C_OP_;
pub type PHAL_I2C_OP = *mut _HAL_I2C_OP_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _I2C_EXD_SUPPORT_ {
    I2C_EXD_RESTART = 1,
    I2C_EXD_GENCALL = 2,
    I2C_EXD_STARTB = 4,
    I2C_EXD_SLVNOACK = 8,
    I2C_EXD_BUS400PF = 16,
    I2C_EXD_SLVACKGC = 32,
    I2C_EXD_USER_REG = 64,
    I2C_EXD_USER_TWOB = 128,
    I2C_EXD_MTR_ADDR_RTY = 256,
    I2C_EXD_MTR_ADDR_UPD = 512,
    I2C_EXD_MTR_HOLD_BUS = 1024,
}
pub type I2C_EXD_SUPPORT = _I2C_EXD_SUPPORT_;
pub type PI2C_EXD_SUPPORT = *mut _I2C_EXD_SUPPORT_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _I2C_OP_TYPE_ {
    I2C_POLL_TYPE = 0,
    I2C_DMA_TYPE = 1,
    I2C_INTR_TYPE = 2,
}
pub type I2C_OP_TYPE = _I2C_OP_TYPE_;
pub type PI2C_OP_TYPE = *mut _I2C_OP_TYPE_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _I2C_PINMUX_ {
    I2C_PIN_S0 = 0,
    I2C_PIN_S1 = 1,
    I2C_PIN_S2 = 2,
    I2C_PIN_S3 = 3,
}
pub type I2C_PINMUX = _I2C_PINMUX_;
pub type PI2C_PINMUX = *mut _I2C_PINMUX_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _I2C_MODULE_STATUS_ { I2C_DISABLE = 0, I2C_ENABLE = 1, }
pub type I2C_MODULE_STATUS = _I2C_MODULE_STATUS_;
pub type PI2C_MODULE_STATUS = *mut _I2C_MODULE_STATUS_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _I2C_Device_STATUS_ {
    I2C_STS_UNINITIAL = 0,
    I2C_STS_INITIALIZED = 1,
    I2C_STS_IDLE = 2,
    I2C_STS_TX_READY = 3,
    I2C_STS_TX_ING = 4,
    I2C_STS_RX_READY = 5,
    I2C_STS_RX_ING = 6,
    I2C_STS_ERROR = 16,
    I2C_STS_TIMEOUT = 17,
}
pub type I2C_Device_STATUS = _I2C_Device_STATUS_;
pub type PI2C_Device_STATUS = *mut _I2C_Device_STATUS_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _I2C_FEATURE_STATUS_ {
    I2C_FEATURE_DISABLED = 0,
    I2C_FEATURE_ENABLED = 1,
}
pub type I2C_FEATURE_STATUS = _I2C_FEATURE_STATUS_;
pub type PI2C_FEATURE_STATUS = *mut _I2C_FEATURE_STATUS_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _I2C_DEV_MODE_ { I2C_SLAVE_MODE = 0, I2C_MASTER_MODE = 1, }
pub type I2C_DEV_MODE = _I2C_DEV_MODE_;
pub type PI2C_DEV_MODE = *mut _I2C_DEV_MODE_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _I2C_DIRECTION_ { I2C_ONLY_TX = 1, I2C_ONLY_RX = 2, I2C_TXRX = 3, }
pub type I2C_DIRECTION = _I2C_DIRECTION_;
pub type PI2C_DIRECTION = *mut _I2C_DIRECTION_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _I2C_DMA_MODULE_SEL_ { I2C_DMA_MODULE_0 = 0, I2C_DMA_MODULE_1 = 1, }
pub type I2C_DMA_MODULE_SEL = _I2C_DMA_MODULE_SEL_;
pub type PI2C_DMA_MODULE_SEL = *mut _I2C_DMA_MODULE_SEL_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _I2C0_DMA_PERI_NUM_ { I2C0_DMA_TX_NUM = 8, I2C0_DMA_RX_NUM = 9, }
pub type I2C0_DMA_PERI_NUM = _I2C0_DMA_PERI_NUM_;
pub type PI2C0_DMA_PERI_NUM = *mut _I2C0_DMA_PERI_NUM_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _I2C1_DMA_PERI_NUM_ { I2C1_DMA_TX_NUM = 10, I2C1_DMA_RX_NUM = 11, }
pub type I2C1_DMA_PERI_NUM = _I2C1_DMA_PERI_NUM_;
pub type PI2C1_DMA_PERI_NUM = *mut _I2C1_DMA_PERI_NUM_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _I2C0_DMA_MODULE_ { I2C0_DMA0 = 0, I2C0_DMA1 = 1, }
pub type I2C0_DMA_MODULE = _I2C0_DMA_MODULE_;
pub type PI2C0_DMA_MODULE = *mut _I2C0_DMA_MODULE_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _I2C1_DMA_MODULE_ { I2C1_DMA0 = 0, I2C1_DMA1 = 1, }
pub type I2C1_DMA_MODULE = _I2C1_DMA_MODULE_;
pub type PI2C1_DMA_MODULE = *mut _I2C1_DMA_MODULE_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _I2C_COMMAND_TYPE_ { I2C_WRITE_CMD = 0, I2C_READ_CMD = 1, }
pub type I2C_COMMAND_TYPE = _I2C_COMMAND_TYPE_;
pub type PI2C_COMMAND_TYPE = *mut _I2C_COMMAND_TYPE_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _I2C_STOP_TYPE_ { I2C_STOP_DIS = 0, I2C_STOP_EN = 1, }
pub type I2C_STOP_TYPE = _I2C_STOP_TYPE_;
pub type PI2C_STOP_TYPE = *mut _I2C_STOP_TYPE_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _I2C_ERR_TYPE_ {
    I2C_ERR_RX_UNDER = 1,
    I2C_ERR_RX_OVER = 2,
    I2C_ERR_TX_OVER = 4,
    I2C_ERR_TX_ABRT = 8,
    I2C_ERR_SLV_TX_NACK = 16,
    I2C_ERR_MST_A_NACK = 18,
    I2C_ERR_MST_D_NACK = 19,
    I2C_ERR_USER_REG_TO = 32,
    I2C_ERR_RX_CMD_TO = 33,
    I2C_ERR_RX_FF_TO = 34,
    I2C_ERR_TX_CMD_TO = 35,
    I2C_ERR_TX_FF_TO = 36,
    I2C_ERR_TX_ADD_TO = 37,
    I2C_ERR_RX_ADD_TO = 38,
}
pub type I2C_ERR_TYPE = _I2C_ERR_TYPE_;
pub type PI2C_ERR_TYPE = *mut _I2C_ERR_TYPE_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _I2C_TIMEOUT_TYPE_ {
    I2C_TIMEOOUT_DISABLE = 0,
    I2C_TIMEOOUT_ENDLESS = 4294967295,
}
pub type I2C_TIMEOUT_TYPE = _I2C_TIMEOUT_TYPE_;
pub type PI2C_TIMEOUT_TYPE = *mut _I2C_TIMEOUT_TYPE_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _SAL_I2C_USERCB_ADPT_ {
    pub USERCB: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                *mut ::ctypes::c_void)>,
    pub USERData: uint32_t,
}
impl ::core::default::Default for _SAL_I2C_USERCB_ADPT_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type SAL_I2C_USERCB_ADPT = _SAL_I2C_USERCB_ADPT_;
pub type PSAL_I2C_USERCB_ADPT = *mut _SAL_I2C_USERCB_ADPT_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _SAL_I2C_USER_CB_ {
    pub pTXCB: PSAL_I2C_USERCB_ADPT,
    pub pTXCCB: PSAL_I2C_USERCB_ADPT,
    pub pRXCB: PSAL_I2C_USERCB_ADPT,
    pub pRXCCB: PSAL_I2C_USERCB_ADPT,
    pub pRDREQCB: PSAL_I2C_USERCB_ADPT,
    pub pERRCB: PSAL_I2C_USERCB_ADPT,
    pub pDMATXCB: PSAL_I2C_USERCB_ADPT,
    pub pDMATXCCB: PSAL_I2C_USERCB_ADPT,
    pub pDMARXCB: PSAL_I2C_USERCB_ADPT,
    pub pDMARXCCB: PSAL_I2C_USERCB_ADPT,
    pub pGENCALLCB: PSAL_I2C_USERCB_ADPT,
}
impl ::core::default::Default for _SAL_I2C_USER_CB_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type SAL_I2C_USER_CB = _SAL_I2C_USER_CB_;
pub type PSAL_I2C_USER_CB = *mut _SAL_I2C_USER_CB_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _SAL_I2C_TRANSFER_BUF_ {
    pub DataLen: uint16_t,
    pub TargetAddr: uint16_t,
    pub RegAddr: uint32_t,
    pub RSVD: uint32_t,
    pub pDataBuf: *mut uint8_t,
}
impl ::core::default::Default for _SAL_I2C_TRANSFER_BUF_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type SAL_I2C_TRANSFER_BUF = _SAL_I2C_TRANSFER_BUF_;
pub type PSAL_I2C_TRANSFER_BUF = *mut _SAL_I2C_TRANSFER_BUF_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _SAL_I2C_DMA_USER_DEF_ {
    pub TxDatSrcWdth: uint8_t,
    pub TxDatDstWdth: uint8_t,
    pub TxDatSrcBstSz: uint8_t,
    pub TxDatDstBstSz: uint8_t,
    pub TxChNo: uint8_t,
    pub RSVD0: uint8_t,
    pub RSVD1: uint16_t,
    pub RxDatSrcWdth: uint8_t,
    pub RxDatDstWdth: uint8_t,
    pub RxDatSrcBstSz: uint8_t,
    pub RxDatDstBstSz: uint8_t,
    pub RxChNo: uint8_t,
    pub RSVD2: uint8_t,
    pub RSVD3: uint16_t,
}
impl ::core::default::Default for _SAL_I2C_DMA_USER_DEF_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type SAL_I2C_DMA_USER_DEF = _SAL_I2C_DMA_USER_DEF_;
pub type PSAL_I2C_DMA_USER_DEF = *mut _SAL_I2C_DMA_USER_DEF_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _RTK_I2C_OP_ {
    pub Init: ::core::option::Option<unsafe extern "C" fn(Data:
                                                              *mut ::ctypes::c_void)
                                         -> HAL_Status>,
    pub DeInit: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                *mut ::ctypes::c_void)
                                           -> HAL_Status>,
    pub Send: ::core::option::Option<unsafe extern "C" fn(Data:
                                                              *mut ::ctypes::c_void)
                                         -> HAL_Status>,
    pub Receive: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                 *mut ::ctypes::c_void)
                                            -> HAL_Status>,
    pub IoCtrl: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                *mut ::ctypes::c_void)
                                           -> HAL_Status>,
    pub PowerCtrl: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                   *mut ::ctypes::c_void)
                                              -> HAL_Status>,
}
impl ::core::default::Default for _RTK_I2C_OP_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type RTK_I2C_OP = _RTK_I2C_OP_;
pub type PRTK_I2C_OP = *mut _RTK_I2C_OP_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _SAL_I2C_HND_ {
    pub DevNum: uint8_t,
    pub PinMux: uint8_t,
    pub OpType: uint8_t,
    pub DevSts: uint8_t,
    pub I2CMaster: uint8_t,
    pub I2CAddrMod: uint8_t,
    pub I2CSpdMod: uint8_t,
    pub I2CAckAddr: uint8_t,
    pub I2CClk: uint16_t,
    pub MasterRead: uint8_t,
    pub I2CDmaSel: uint8_t,
    pub I2CTxDMARqLv: uint8_t,
    pub I2CRxDMARqLv: uint8_t,
    pub RSVD0: uint16_t,
    pub AddRtyTimeOut: uint32_t,
    pub I2CExd: uint32_t,
    pub ErrType: uint32_t,
    pub TimeOut: uint32_t,
    pub pInitDat: PHAL_I2C_INIT_DAT,
    pub pTXBuf: PSAL_I2C_TRANSFER_BUF,
    pub pRXBuf: PSAL_I2C_TRANSFER_BUF,
    pub pUserCB: PSAL_I2C_USER_CB,
    pub pDMAConf: PSAL_I2C_DMA_USER_DEF,
}
impl ::core::default::Default for _SAL_I2C_HND_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type SAL_I2C_HND = _SAL_I2C_HND_;
pub type PSAL_I2C_HND = *mut _SAL_I2C_HND_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _SAL_I2C_HND_PRIV_ {
    pub ppSalI2CHnd: *mut *mut ::ctypes::c_void,
    pub SalI2CHndPriv: SAL_I2C_HND,
}
impl ::core::default::Default for _SAL_I2C_HND_PRIV_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type SAL_I2C_HND_PRIV = _SAL_I2C_HND_PRIV_;
pub type PSAL_I2C_HND_PRIV = *mut _SAL_I2C_HND_PRIV_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _SAL_I2C_MNGT_ADPT_ {
    pub pSalHndPriv: PSAL_I2C_HND_PRIV,
    pub pHalInitDat: PHAL_I2C_INIT_DAT,
    pub pHalOp: PHAL_I2C_OP,
    pub pHalOpInit: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                    *mut ::ctypes::c_void)>,
    pub pIrqHnd: PIRQ_HANDLE,
    pub pUserCB: PSAL_I2C_USER_CB,
    pub MstRDCmdCnt: uint32_t,
    pub InnerTimeOut: uint32_t,
    pub pSalIrqFunc: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                     *mut ::ctypes::c_void)>,
    pub pDMAConf: PSAL_I2C_DMA_USER_DEF,
    pub pHalTxGdmaAdp: PHAL_GDMA_ADAPTER,
    pub pHalRxGdmaAdp: PHAL_GDMA_ADAPTER,
    pub pHalGdmaOp: PHAL_GDMA_OP,
    pub pHalGdmaOpInit: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                        *mut ::ctypes::c_void)>,
    pub pIrqTxGdmaHnd: PIRQ_HANDLE,
    pub pIrqRxGdmaHnd: PIRQ_HANDLE,
    pub pSalDMATxIrqFunc: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                          *mut ::ctypes::c_void)>,
    pub pSalDMARxIrqFunc: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                          *mut ::ctypes::c_void)>,
    pub RSVD: uint32_t,
}
impl ::core::default::Default for _SAL_I2C_MNGT_ADPT_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type SAL_I2C_MNGT_ADPT = _SAL_I2C_MNGT_ADPT_;
pub type PSAL_I2C_MNGT_ADPT = *mut _SAL_I2C_MNGT_ADPT_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _HAL_PWM_ADAPTER_ {
    pub pwm_id: uint8_t,
    pub sel: uint8_t,
    pub gtimer_id: uint8_t,
    pub enable: uint8_t,
    pub tick_time: uint32_t,
    pub period: uint32_t,
    pub pulsewidth: uint32_t,
}
impl ::core::default::Default for _HAL_PWM_ADAPTER_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type HAL_PWM_ADAPTER = _HAL_PWM_ADAPTER_;
pub type PHAL_PWM_ADAPTER = *mut _HAL_PWM_ADAPTER_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _I2S_DBG_LVL_ { HAL_I2S_LVL = 1, SAL_I2S_LVL = 2, VERI_I2S_LVL = 3, }
pub type I2S_DBG_LVL = _I2S_DBG_LVL_;
pub type PI2S_DBG_LVL = *mut _I2S_DBG_LVL_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _I2S_CTL_FORMAT {
    FormatI2s = 0,
    FormatLeftJustified = 1,
    FormatRightJustified = 2,
}
pub type I2S_CTL_FORMAT = _I2S_CTL_FORMAT;
pub type PI2S_CTL_FORMAT = *mut _I2S_CTL_FORMAT;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _I2S_CTL_CHNUM {
    ChannelStereo = 0,
    Channel5p1 = 1,
    ChannelMono = 2,
}
pub type I2S_CTL_CHNUM = _I2S_CTL_CHNUM;
pub type PI2S_CTL_CHNUM = *mut _I2S_CTL_CHNUM;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _I2S_CTL_TRX_ACT { RxOnly = 0, TxOnly = 1, TXRX = 2, }
pub type I2S_CTL_TRX_ACT = _I2S_CTL_TRX_ACT;
pub type PI2S_CTL_TRX_ACT = *mut _I2S_CTL_TRX_ACT;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _I2S_SETTING_PAGE_NUM {
    I2s1Page = 0,
    I2s2Page = 1,
    I2s3Page = 2,
    I2s4Page = 3,
}
pub type I2S_SETTING_PAGE_NUM = _I2S_SETTING_PAGE_NUM;
pub type PI2S_SETTING_PAGE_NUM = *mut _I2S_SETTING_PAGE_NUM;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _I2S_SETTING_SR {
    I2sSR8K = 0,
    I2sSR16K = 1,
    I2sSR24K = 2,
    I2sSR32K = 3,
    I2sSR48K = 5,
    I2sSR44p1K = 21,
    I2sSR96K = 6,
    I2sSR88p2K = 22,
}
pub type I2S_SETTING_SR = _I2S_SETTING_SR;
pub type PI2S_SETTING_SR = *mut _I2S_SETTING_SR;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _HAL_I2S_INIT_DAT_ {
    pub I2SIdx: uint8_t,
    pub I2SEn: uint8_t,
    pub I2SMaster: uint8_t,
    pub I2SWordLen: uint8_t,
    pub I2SChNum: uint8_t,
    pub I2SPageNum: uint8_t,
    pub I2SPageSize: uint16_t,
    pub I2STxData: *mut uint8_t,
    pub I2SRxData: *mut uint8_t,
    pub I2STxIntrMSK: uint32_t,
    pub I2STxIntrClr: uint32_t,
    pub I2SRxIntrMSK: uint32_t,
    pub I2SRxIntrClr: uint32_t,
    pub I2STxIdx: uint16_t,
    pub I2SRxIdx: uint16_t,
    pub I2SHWTxIdx: uint16_t,
    pub I2SHWRxIdx: uint16_t,
    pub I2SRate: uint16_t,
    pub I2STRxAct: uint8_t,
}
impl ::core::default::Default for _HAL_I2S_INIT_DAT_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type HAL_I2S_INIT_DAT = _HAL_I2S_INIT_DAT_;
pub type PHAL_I2S_INIT_DAT = *mut _HAL_I2S_INIT_DAT_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _I2S_MODULE_SEL_ { I2S0_SEL = 0, I2S1_SEL = 1, }
pub type I2S_MODULE_SEL = _I2S_MODULE_SEL_;
pub type PI2S_MODULE_SEL = *mut _I2S_MODULE_SEL_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _HAL_I2S_OP_ {
    pub HalI2SInit: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                    *mut ::ctypes::c_void)
                                               -> RTK_STATUS>,
    pub HalI2SDeInit: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                      *mut ::ctypes::c_void)
                                                 -> RTK_STATUS>,
    pub HalI2STx: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                  *mut ::ctypes::c_void,
                                                              pBuff:
                                                                  *mut uint8_t)
                                             -> RTK_STATUS>,
    pub HalI2SRx: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                  *mut ::ctypes::c_void,
                                                              pBuff:
                                                                  *mut uint8_t)
                                             -> RTK_STATUS>,
    pub HalI2SEnable: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                      *mut ::ctypes::c_void)
                                                 -> RTK_STATUS>,
    pub HalI2SIntrCtrl: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                        *mut ::ctypes::c_void)
                                                   -> RTK_STATUS>,
    pub HalI2SReadReg: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                       *mut ::ctypes::c_void,
                                                                   I2SReg:
                                                                       uint8_t)
                                                  -> uint32_t>,
    pub HalI2SSetRate: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                       *mut ::ctypes::c_void)
                                                  -> RTK_STATUS>,
    pub HalI2SSetWordLen: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                          *mut ::ctypes::c_void)
                                                     -> RTK_STATUS>,
    pub HalI2SSetChNum: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                        *mut ::ctypes::c_void)
                                                   -> RTK_STATUS>,
    pub HalI2SSetPageNum: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                          *mut ::ctypes::c_void)
                                                     -> RTK_STATUS>,
    pub HalI2SSetPageSize: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                           *mut ::ctypes::c_void)
                                                      -> RTK_STATUS>,
    pub HalI2SClrIntr: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                       *mut ::ctypes::c_void)
                                                  -> RTK_STATUS>,
    pub HalI2SClrAllIntr: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                          *mut ::ctypes::c_void)
                                                     -> RTK_STATUS>,
    pub HalI2SDMACtrl: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                       *mut ::ctypes::c_void)
                                                  -> RTK_STATUS>,
}
impl ::core::default::Default for _HAL_I2S_OP_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type HAL_I2S_OP = _HAL_I2S_OP_;
pub type PHAL_I2S_OP = *mut _HAL_I2S_OP_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _I2S_PINMUX_ { I2S_S0 = 0, I2S_S1 = 1, I2S_S2 = 2, I2S_S3 = 3, }
pub type I2S_PINMUX = _I2S_PINMUX_;
pub type PI2S_PINMUX = *mut _I2S_PINMUX_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _I2S_MODULE_STATUS_ { I2S_DISABLE = 0, I2S_ENABLE = 1, }
pub type I2S_MODULE_STATUS = _I2S_MODULE_STATUS_;
pub type PI2S_MODULE_STATUS = *mut _I2S_MODULE_STATUS_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _I2S_Device_STATUS_ {
    I2S_STS_UNINITIAL = 0,
    I2S_STS_INITIALIZED = 1,
    I2S_STS_IDLE = 2,
    I2S_STS_TX_READY = 3,
    I2S_STS_TX_ING = 4,
    I2S_STS_RX_READY = 5,
    I2S_STS_RX_ING = 6,
    I2S_STS_TRX_READY = 7,
    I2S_STS_TRX_ING = 8,
    I2S_STS_ERROR = 9,
}
pub type I2S_Device_STATUS = _I2S_Device_STATUS_;
pub type PI2S_Device_STATUS = *mut _I2S_Device_STATUS_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _I2S_FEATURE_STATUS_ {
    I2S_FEATURE_DISABLED = 0,
    I2S_FEATURE_ENABLED = 1,
}
pub type I2S_FEATURE_STATUS = _I2S_FEATURE_STATUS_;
pub type PI2S_FEATURE_STATUS = *mut _I2S_FEATURE_STATUS_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _I2S_DEV_MODE_ { I2S_MASTER_MODE = 0, I2S_SLAVE_MODE = 1, }
pub type I2S_DEV_MODE = _I2S_DEV_MODE_;
pub type PI2S_DEV_MODE = *mut _I2S_DEV_MODE_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _I2S_WORD_LEN_ { I2S_WL_16 = 0, I2S_WL_24 = 1, }
pub type I2S_WORD_LEN = _I2S_WORD_LEN_;
pub type PI2S_WORD_LEN = *mut _I2S_WORD_LEN_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _I2S_DIRECTION_ { I2S_ONLY_RX = 0, I2S_ONLY_TX = 1, I2S_TXRX = 2, }
pub type I2S_DIRECTION = _I2S_DIRECTION_;
pub type PI2S_DIRECTION = *mut _I2S_DIRECTION_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _I2S_CH_NUM_ { I2S_CH_STEREO = 0, I2S_CH_RSVD = 1, I2S_CH_MONO = 2, }
pub type I2S_CH_NUM = _I2S_CH_NUM_;
pub type PI2S_CH_NUM = *mut _I2S_CH_NUM_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _I2S_PAGE_NUM_ {
    I2S_1PAGE = 0,
    I2S_2PAGE = 1,
    I2S_3PAGE = 2,
    I2S_4PAGE = 3,
}
pub type I2S_PAGE_NUM = _I2S_PAGE_NUM_;
pub type PI2S_PAGE_NUM = *mut _I2S_PAGE_NUM_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _I2S_SAMPLE_RATE_ {
    I2S_SR_8KHZ = 0,
    I2S_SR_16KHZ = 1,
    I2S_SR_24KHZ = 2,
    I2S_SR_32KHZ = 3,
    I2S_SR_48KHZ = 5,
    I2S_SR_96KHZ = 6,
    I2S_SR_7p35KHZ = 16,
    I2S_SR_11p02KHZ = 17,
    I2S_SR_22p05KHZ = 18,
    I2S_SR_29p4KHZ = 19,
    I2S_SR_44p1KHZ = 21,
    I2S_SR_88p2KHZ = 22,
}
pub type I2S_SAMPLE_RATE = _I2S_SAMPLE_RATE_;
pub type PI2S_SAMPLE_RATE = *mut _I2S_SAMPLE_RATE_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _I2S_TX_IMR_ {
    I2S_TX_INT_PAGE0_OK = 1,
    I2S_TX_INT_PAGE1_OK = 2,
    I2S_TX_INT_PAGE2_OK = 4,
    I2S_TX_INT_PAGE3_OK = 8,
    I2S_TX_INT_FULL = 16,
    I2S_TX_INT_EMPTY = 32,
}
pub type I2S_TX_IMR = _I2S_TX_IMR_;
pub type PI2S_TX_IMR = *mut _I2S_TX_IMR_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _I2S_RX_IMR_ {
    I2S_RX_INT_PAGE0_OK = 1,
    I2S_RX_INT_PAGE1_OK = 2,
    I2S_RX_INT_PAGE2_OK = 4,
    I2S_RX_INT_PAGE3_OK = 8,
    I2S_RX_INT_EMPTY = 16,
    I2S_RX_INT_FULL = 32,
}
pub type I2S_RX_IMR = _I2S_RX_IMR_;
pub type PI2S_RX_IMR = *mut _I2S_RX_IMR_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _SAL_I2S_USER_CB_ {
    pub TXCB: ::core::option::Option<unsafe extern "C" fn(Data:
                                                              *mut ::ctypes::c_void)>,
    pub TXCCB: ::core::option::Option<unsafe extern "C" fn(Data:
                                                               *mut ::ctypes::c_void)>,
    pub RXCB: ::core::option::Option<unsafe extern "C" fn(Data:
                                                              *mut ::ctypes::c_void)>,
    pub RXCCB: ::core::option::Option<unsafe extern "C" fn(Data:
                                                               *mut ::ctypes::c_void)>,
    pub RDREQCB: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                 *mut ::ctypes::c_void)>,
    pub ERRCB: ::core::option::Option<unsafe extern "C" fn(Data:
                                                               *mut ::ctypes::c_void)>,
    pub GENCALLCB: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                   *mut ::ctypes::c_void)>,
}
impl ::core::default::Default for _SAL_I2S_USER_CB_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type SAL_I2S_USER_CB = _SAL_I2S_USER_CB_;
pub type PSAL_I2S_USER_CB = *mut _SAL_I2S_USER_CB_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _I2S_USER_CB_ {
    pub TxCCB: ::core::option::Option<unsafe extern "C" fn(id: uint32_t,
                                                           pbuf:
                                                               *mut ::ctypes::c_char)>,
    pub TxCBId: uint32_t,
    pub RxCCB: ::core::option::Option<unsafe extern "C" fn(id: uint32_t,
                                                           pbuf:
                                                               *mut ::ctypes::c_char)>,
    pub RxCBId: uint32_t,
}
impl ::core::default::Default for _I2S_USER_CB_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type I2S_USER_CB = _I2S_USER_CB_;
pub type PI2S_USER_CB = *mut _I2S_USER_CB_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _HAL_I2S_ADAPTER_ {
    pub DevNum: uint8_t,
    pub PinMux: uint8_t,
    pub RSVD0: uint8_t,
    pub DevSts: uint8_t,
    pub RSVD2: uint32_t,
    pub I2SExd: uint32_t,
    pub ErrType: uint32_t,
    pub TimeOut: uint32_t,
    pub pInitDat: PHAL_I2S_INIT_DAT,
    pub UserCB: I2S_USER_CB,
    pub IrqHandle: IRQ_HANDLE,
    pub TxPageList: [*mut uint32_t; 4usize],
    pub RxPageList: [*mut uint32_t; 4usize],
}
impl ::core::default::Default for _HAL_I2S_ADAPTER_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type HAL_I2S_ADAPTER = _HAL_I2S_ADAPTER_;
pub type PHAL_I2S_ADAPTER = *mut _HAL_I2S_ADAPTER_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _HAL_I2S_DEF_SETTING_ {
    pub I2SMaster: uint8_t,
    pub DevSts: uint8_t,
    pub I2SChNum: uint8_t,
    pub I2SPageNum: uint8_t,
    pub I2STRxAct: uint8_t,
    pub I2SWordLen: uint8_t,
    pub I2SPageSize: uint16_t,
    pub I2SRate: uint16_t,
    pub I2STxIntrMSK: uint32_t,
    pub I2SRxIntrMSK: uint32_t,
}
impl ::core::default::Default for _HAL_I2S_DEF_SETTING_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type HAL_I2S_DEF_SETTING = _HAL_I2S_DEF_SETTING_;
pub type PHAL_I2S_DEF_SETTING = *mut _HAL_I2S_DEF_SETTING_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _DAC_DBG_LVL_ { HAL_DAC_LVL = 0, SAL_DAC_LVL = 2, VERI_DAC_LVL = 4, }
pub type DAC_DBG_LVL = _DAC_DBG_LVL_;
pub type PDAC_DBG_LVL = *mut _DAC_DBG_LVL_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _DAC_MODULE_SEL_ { DAC0_SEL = 0, DAC1_SEL = 1, }
pub type DAC_MODULE_SEL = _DAC_MODULE_SEL_;
pub type PDAC_MODULE_SEL = *mut _DAC_MODULE_SEL_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _DAC_MODULE_STATUS_ { DAC_DISABLE = 0, DAC_ENABLE = 1, }
pub type DAC_MODULE_STATUS = _DAC_MODULE_STATUS_;
pub type PDAC_MODULE_STATUS = *mut _DAC_MODULE_STATUS_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _DAC_DATA_RATE_ { DAC_DATA_RATE_10K = 0, DAC_DATA_RATE_250K = 1, }
pub type DAC_DATA_RATE = _DAC_DATA_RATE_;
pub type PDAC_DATA_RATE = *mut _DAC_DATA_RATE_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _DAC_DATA_ENDIAN_ {
    DAC_DATA_ENDIAN_LITTLE = 0,
    DAC_DATA_ENDIAN_BIG = 1,
}
pub type DAC_DATA_ENDIAN = _DAC_DATA_ENDIAN_;
pub type PDAC_DATA_ENDIAN = *mut _DAC_DATA_ENDIAN_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _DAC_DEBUG_SEL_ { DAC_DBG_SEL_DISABLE = 0, DAC_DBG_SEL_ENABLE = 1, }
pub type DAC_DEBUG_SEL = _DAC_DEBUG_SEL_;
pub type PDAC_DEBUG_SEL = *mut _DAC_DEBUG_SEL_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _DAC_DSC_DEBUG_SEL_ {
    DAC_DSC_DBG_SEL_DISABLE = 0,
    DAC_DSC_DBG_SEL_ENABLE = 1,
}
pub type DAC_DSC_DEBUG_SEL = _DAC_DSC_DEBUG_SEL_;
pub type PDAC_DSC_DEBUG_SEL = *mut _DAC_DSC_DEBUG_SEL_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _DAC_BYPASS_DSC_SEL_ {
    DAC_BYPASS_DSC_SEL_DISABLE = 0,
    DAC_BYPASS_DSC_SEL_ENABLE = 1,
}
pub type DAC_BYPASS_DSC_SEL = _DAC_BYPASS_DSC_SEL_;
pub type PDAC_BYPASS_DSC_SEL = *mut _DAC_BYPASS_DSC_SEL_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _DAC_FEATURE_STATUS_ {
    DAC_FEATURE_DISABLED = 0,
    DAC_FEATURE_ENABLED = 1,
}
pub type DAC_FEATURE_STATUS = _DAC_FEATURE_STATUS_;
pub type PDAC_FEATURE_STATUS = *mut _DAC_FEATURE_STATUS_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _DAC_OP_TYPE_ {
    DAC_POLL_TYPE = 0,
    DAC_DMA_TYPE = 1,
    DAC_INTR_TYPE = 2,
}
pub type DAC_OP_TYPE = _DAC_OP_TYPE_;
pub type PDAC_OP_TYPE = *mut _DAC_OP_TYPE_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _DAC_Device_STATUS_ {
    DAC_STS_UNINITIAL = 0,
    DAC_STS_INITIALIZED = 1,
    DAC_STS_IDLE = 2,
    DAC_STS_TX_READY = 3,
    DAC_STS_TX_ING = 4,
    DAC_STS_RX_READY = 5,
    DAC_STS_RX_ING = 6,
    DAC_STS_ERROR = 7,
}
pub type DAC_Device_STATUS = _DAC_Device_STATUS_;
pub type PDAC_Device_STATUS = *mut _DAC_Device_STATUS_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _DAC_ERR_TYPE_ {
    DAC_ERR_FIFO_OVER = 4,
    DAC_ERR_FIFO_STOP = 8,
    DAC_ERR_FIFO_WRFAIL = 16,
    DAC_ERR_FIFO_DSC_OVER0 = 32,
    DAC_ERR_FIFO_DSC_OVER1 = 64,
}
pub type DAC_ERR_TYPE = _DAC_ERR_TYPE_;
pub type PDAC_ERR_TYPE = *mut _DAC_ERR_TYPE_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _DAC_INPUT_TYPE_ {
    DAC_INPUT_SINGLE_WR = 1,
    DAC_INPUT_DMA_ONEBLK = 2,
    DAC_INPUT_DMA_LLP = 3,
}
pub type DAC_INPUT_TYPE = _DAC_INPUT_TYPE_;
pub type PDAC_INPUT_TYPE = *mut _DAC_INPUT_TYPE_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _HAL_DAC_INIT_DAT_ {
    pub DACIdx: uint8_t,
    pub DACEn: uint8_t,
    pub DACDataRate: uint8_t,
    pub DACEndian: uint8_t,
    pub DACFilterSet: uint8_t,
    pub DACBurstSz: uint8_t,
    pub DACDbgSel: uint8_t,
    pub DACDscDbgSel: uint8_t,
    pub DACBPDsc: uint8_t,
    pub DACDeltaSig: uint8_t,
    pub RSVD1: uint16_t,
    pub DACData: *mut uint32_t,
    pub DACPWCtrl: uint32_t,
    pub DACAnaCtrl0: uint32_t,
    pub DACAnaCtrl1: uint32_t,
    pub DACIntrMSK: uint32_t,
}
impl ::core::default::Default for _HAL_DAC_INIT_DAT_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type HAL_DAC_INIT_DAT = _HAL_DAC_INIT_DAT_;
pub type PHAL_DAC_INIT_DAT = *mut _HAL_DAC_INIT_DAT_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _HAL_DAC_OP_ {
    pub HalDACInit: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                    *mut ::ctypes::c_void)
                                               -> RTK_STATUS>,
    pub HalDACDeInit: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                      *mut ::ctypes::c_void)
                                                 -> RTK_STATUS>,
    pub HalDACEnable: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                      *mut ::ctypes::c_void)
                                                 -> RTK_STATUS>,
    pub HalDACSend: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                    *mut ::ctypes::c_void)
                                               -> uint8_t>,
    pub HalDACIntrCtrl: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                        *mut ::ctypes::c_void)
                                                   -> RTK_STATUS>,
    pub HalDACReadReg: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                       *mut ::ctypes::c_void,
                                                                   DACReg:
                                                                       uint8_t)
                                                  -> uint32_t>,
}
impl ::core::default::Default for _HAL_DAC_OP_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type HAL_DAC_OP = _HAL_DAC_OP_;
pub type PHAL_DAC_OP = *mut _HAL_DAC_OP_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _SAL_DAC_USERCB_ADPT_ {
    pub USERCB: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                *mut ::ctypes::c_void)>,
    pub USERData: uint32_t,
}
impl ::core::default::Default for _SAL_DAC_USERCB_ADPT_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type SAL_DAC_USERCB_ADPT = _SAL_DAC_USERCB_ADPT_;
pub type PSAL_DAC_USERCB_ADPT = *mut _SAL_DAC_USERCB_ADPT_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _SAL_DAC_USER_CB_ {
    pub pTXCB: PSAL_DAC_USERCB_ADPT,
    pub pTXCCB: PSAL_DAC_USERCB_ADPT,
    pub pRXCB: PSAL_DAC_USERCB_ADPT,
    pub pRXCCB: PSAL_DAC_USERCB_ADPT,
    pub pRDREQCB: PSAL_DAC_USERCB_ADPT,
    pub pERRCB: PSAL_DAC_USERCB_ADPT,
    pub pDMATXCB: PSAL_DAC_USERCB_ADPT,
    pub pDMATXCCB: PSAL_DAC_USERCB_ADPT,
    pub pDMARXCB: PSAL_DAC_USERCB_ADPT,
    pub pDMARXCCB: PSAL_DAC_USERCB_ADPT,
}
impl ::core::default::Default for _SAL_DAC_USER_CB_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type SAL_DAC_USER_CB = _SAL_DAC_USER_CB_;
pub type PSAL_DAC_USER_CB = *mut _SAL_DAC_USER_CB_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _SAL_DAC_TRANSFER_BUF_ {
    pub DataLen: uint32_t,
    pub pDataBuf: *mut uint32_t,
    pub RSVD: uint32_t,
}
impl ::core::default::Default for _SAL_DAC_TRANSFER_BUF_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type SAL_DAC_TRANSFER_BUF = _SAL_DAC_TRANSFER_BUF_;
pub type PSAL_DAC_TRANSFER_BUF = *mut _SAL_DAC_TRANSFER_BUF_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _SAL_DAC_DMA_USER_DEF_ {
    pub TxDatSrcWdth: uint8_t,
    pub TxDatDstWdth: uint8_t,
    pub TxDatSrcBstSz: uint8_t,
    pub TxDatDstBstSz: uint8_t,
    pub TxChNo: uint8_t,
    pub LlpCtrl: uint8_t,
    pub RSVD0: uint16_t,
    pub MaxMultiBlk: uint32_t,
    pub pLlix: uint32_t,
    pub pBlockSizeList: uint32_t,
}
impl ::core::default::Default for _SAL_DAC_DMA_USER_DEF_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type SAL_DAC_DMA_USER_DEF = _SAL_DAC_DMA_USER_DEF_;
pub type PSAL_DAC_DMA_USER_DEF = *mut _SAL_DAC_DMA_USER_DEF_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _SAL_DAC_HND_ {
    pub DevNum: uint8_t,
    pub PinMux: uint8_t,
    pub OpType: uint8_t,
    pub DevSts: uint8_t,
    pub DACInType: uint8_t,
    pub RSVD0: uint8_t,
    pub RSVD1: uint16_t,
    pub DACExd: uint32_t,
    pub ErrType: uint32_t,
    pub TimeOut: uint32_t,
    pub pInitDat: PHAL_DAC_INIT_DAT,
    pub pTXBuf: PSAL_DAC_TRANSFER_BUF,
    pub pUserCB: PSAL_DAC_USER_CB,
    pub pDMAConf: PSAL_DAC_DMA_USER_DEF,
}
impl ::core::default::Default for _SAL_DAC_HND_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type SAL_DAC_HND = _SAL_DAC_HND_;
pub type PSAL_DAC_HND = *mut _SAL_DAC_HND_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _SAL_DAC_HND_PRIV_ {
    pub ppSalDACHnd: *mut *mut ::ctypes::c_void,
    pub SalDACHndPriv: SAL_DAC_HND,
}
impl ::core::default::Default for _SAL_DAC_HND_PRIV_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type SAL_DAC_HND_PRIV = _SAL_DAC_HND_PRIV_;
pub type PSAL_DAC_HND_PRIV = *mut _SAL_DAC_HND_PRIV_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _SAL_DAC_MNGT_ADPT_ {
    pub pSalHndPriv: PSAL_DAC_HND_PRIV,
    pub pHalInitDat: PHAL_DAC_INIT_DAT,
    pub pHalOp: PHAL_DAC_OP,
    pub pHalOpInit: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                    *mut ::ctypes::c_void)>,
    pub pIrqHnd: PIRQ_HANDLE,
    pub pUserCB: PSAL_DAC_USER_CB,
    pub pSalIrqFunc: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                     *mut ::ctypes::c_void)>,
    pub pDMAConf: PSAL_DAC_DMA_USER_DEF,
    pub pHalGdmaAdp: PHAL_GDMA_ADAPTER,
    pub pHalGdmaOp: PHAL_GDMA_OP,
    pub pHalGdmaOpInit: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                        *mut ::ctypes::c_void)>,
    pub pIrqGdmaHnd: PIRQ_HANDLE,
    pub pSalDMAIrqFunc: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                        *mut ::ctypes::c_void)>,
}
impl ::core::default::Default for _SAL_DAC_MNGT_ADPT_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type SAL_DAC_MNGT_ADPT = _SAL_DAC_MNGT_ADPT_;
pub type PSAL_DAC_MNGT_ADPT = *mut _SAL_DAC_MNGT_ADPT_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _ADC_DBG_LVL_ { HAL_ADC_LVL = 1, SAL_ADC_LVL = 2, VERI_ADC_LVL = 4, }
pub type ADC_DBG_LVL = _ADC_DBG_LVL_;
pub type PADC_DBG_LVL = *mut _ADC_DBG_LVL_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _ADC_MODULE_SEL_ {
    ADC0_SEL = 0,
    ADC1_SEL = 1,
    ADC2_SEL = 2,
    ADC3_SEL = 3,
}
pub type ADC_MODULE_SEL = _ADC_MODULE_SEL_;
pub type PADC_MODULE_SEL = *mut _ADC_MODULE_SEL_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _ADC_MODULE_STATUS_ { ADC_DISABLE = 0, ADC_ENABLE = 1, }
pub type ADC_MODULE_STATUS = _ADC_MODULE_STATUS_;
pub type PADC_MODULE_STATUS = *mut _ADC_MODULE_STATUS_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _ADC_DATA_ENDIAN_ {
    ADC_DATA_ENDIAN_LITTLE = 0,
    ADC_DATA_ENDIAN_BIG = 1,
}
pub type ADC_DATA_ENDIAN = _ADC_DATA_ENDIAN_;
pub type PADC_DATA_ENDIAN = *mut _ADC_DATA_ENDIAN_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _ADC_DEBUG_SEL_ { ADC_DBG_SEL_DISABLE = 0, ADC_DBG_SEL_ENABLE = 1, }
pub type ADC_DEBUG_SEL = _ADC_DEBUG_SEL_;
pub type PADC_DEBUG_SEL = *mut _ADC_DEBUG_SEL_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _ADC_COMPARE_SET_ {
    ADC_COMP_SMALLER_THAN = 0,
    ADC_COMP_GREATER_THAN = 1,
}
pub type ADC_COMPARE_SET = _ADC_COMPARE_SET_;
pub type PADC_COMPARE_SET = *mut _ADC_COMPARE_SET_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _ADC_FEATURE_STATUS_ {
    ADC_FEATURE_DISABLED = 0,
    ADC_FEATURE_ENABLED = 1,
}
pub type ADC_FEATURE_STATUS = _ADC_FEATURE_STATUS_;
pub type PADC_FEATURE_STATUS = *mut _ADC_FEATURE_STATUS_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _ADC_OP_TYPE_ {
    ADC_RDREG_TYPE = 0,
    ADC_DMA_TYPE = 1,
    ADC_INTR_TYPE = 2,
}
pub type ADC_OP_TYPE = _ADC_OP_TYPE_;
pub type PADC_OP_TYPE = *mut _ADC_OP_TYPE_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _ADC_DEVICE_STATUS_ {
    ADC_STS_UNINITIAL = 0,
    ADC_STS_INITIALIZED = 1,
    ADC_STS_IDLE = 2,
    ADC_STS_TX_READY = 3,
    ADC_STS_TX_ING = 4,
    ADC_STS_RX_READY = 5,
    ADC_STS_RX_ING = 6,
    ADC_STS_ERROR = 7,
    ADC_STS_FULL = 8,
}
pub type ADC_DEVICE_STATUS = _ADC_DEVICE_STATUS_;
pub type PADC_DEVICE_STATUS = *mut _ADC_DEVICE_STATUS_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _ADC_ERR_TYPE_ { ADC_ERR_FIFO_RD_ERROR = 64, }
pub type ADC_ERR_TYPE = _ADC_ERR_TYPE_;
pub type PADC_ERR_TYPE = *mut _ADC_ERR_TYPE_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _ADC_INITAIL_STATUS_ {
    ADC0_INITED = 1,
    ADC1_INITED = 2,
    ADC2_INITED = 4,
    ADC3_INITED = 8,
}
pub type ADC_INITAIL_STATUS = _ADC_INITAIL_STATUS_;
pub type PADC_INITAIL_STATUS = *mut _ADC_INITAIL_STATUS_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _HAL_ADC_INIT_DAT_ {
    pub ADCIdx: uint8_t,
    pub ADCEn: uint8_t,
    pub ADCEndian: uint8_t,
    pub ADCBurstSz: uint8_t,
    pub ADCCompOnly: uint8_t,
    pub ADCOneShotEn: uint8_t,
    pub ADCOverWREn: uint8_t,
    pub ADCOneShotTD: uint8_t,
    pub ADCCompCtrl: uint16_t,
    pub ADCCompTD: uint16_t,
    pub ADCDataRate: uint8_t,
    pub ADCAudioEn: uint8_t,
    pub ADCEnManul: uint8_t,
    pub ADCDbgSel: uint8_t,
    pub RSVD0: uint32_t,
    pub ADCData: *mut uint32_t,
    pub ADCPWCtrl: uint32_t,
    pub ADCIntrMSK: uint32_t,
    pub ADCAnaParAd3: uint32_t,
    pub ADCInInput: uint32_t,
}
impl ::core::default::Default for _HAL_ADC_INIT_DAT_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type HAL_ADC_INIT_DAT = _HAL_ADC_INIT_DAT_;
pub type PHAL_ADC_INIT_DAT = *mut _HAL_ADC_INIT_DAT_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _HAL_ADC_OP_ {
    pub HalADCInit: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                    *mut ::ctypes::c_void)
                                               -> RTK_STATUS>,
    pub HalADCDeInit: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                      *mut ::ctypes::c_void)
                                                 -> RTK_STATUS>,
    pub HalADCEnable: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                      *mut ::ctypes::c_void)
                                                 -> RTK_STATUS>,
    pub HalADCReceive: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                       *mut ::ctypes::c_void)
                                                  -> uint32_t>,
    pub HalADCIntrCtrl: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                        *mut ::ctypes::c_void)
                                                   -> RTK_STATUS>,
    pub HalADCReadReg: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                       *mut ::ctypes::c_void,
                                                                   ADCReg:
                                                                       uint8_t)
                                                  -> uint32_t>,
}
impl ::core::default::Default for _HAL_ADC_OP_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type HAL_ADC_OP = _HAL_ADC_OP_;
pub type PHAL_ADC_OP = *mut _HAL_ADC_OP_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _SAL_ADC_USERCB_ADPT_ {
    pub USERCB: ::core::option::Option<unsafe extern "C" fn(Data:
                                                                *mut ::ctypes::c_void)>,
    pub USERData: uint32_t,
}
impl ::core::default::Default for _SAL_ADC_USERCB_ADPT_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type SAL_ADC_USERCB_ADPT = _SAL_ADC_USERCB_ADPT_;
pub type PSAL_ADC_USERCB_ADPT = *mut _SAL_ADC_USERCB_ADPT_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _SAL_ADC_USER_CB_ {
    pub pTXCB: PSAL_ADC_USERCB_ADPT,
    pub pTXCCB: PSAL_ADC_USERCB_ADPT,
    pub pRXCB: PSAL_ADC_USERCB_ADPT,
    pub pRXCCB: PSAL_ADC_USERCB_ADPT,
    pub pRDREQCB: PSAL_ADC_USERCB_ADPT,
    pub pERRCB: PSAL_ADC_USERCB_ADPT,
    pub pDMATXCB: PSAL_ADC_USERCB_ADPT,
    pub pDMATXCCB: PSAL_ADC_USERCB_ADPT,
    pub pDMARXCB: PSAL_ADC_USERCB_ADPT,
    pub pDMARXCCB: PSAL_ADC_USERCB_ADPT,
}
impl ::core::default::Default for _SAL_ADC_USER_CB_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type SAL_ADC_USER_CB = _SAL_ADC_USER_CB_;
pub type PSAL_ADC_USER_CB = *mut _SAL_ADC_USER_CB_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _SAL_ADC_TRANSFER_BUF_ {
    pub DataLen: uint32_t,
    pub pDataBuf: *mut uint32_t,
    pub RSVD: uint32_t,
}
impl ::core::default::Default for _SAL_ADC_TRANSFER_BUF_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type SAL_ADC_TRANSFER_BUF = _SAL_ADC_TRANSFER_BUF_;
pub type PSAL_ADC_TRANSFER_BUF = *mut _SAL_ADC_TRANSFER_BUF_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _SAL_ADC_DMA_USER_DEF_ {
    pub TxDatSrcWdth: uint8_t,
    pub TxDatDstWdth: uint8_t,
    pub TxDatSrcBstSz: uint8_t,
    pub TxDatDstBstSz: uint8_t,
    pub TxChNo: uint8_t,
    pub LlpCtrl: uint8_t,
    pub RSVD0: uint16_t,
    pub MaxMultiBlk: uint32_t,
    pub pLlix: uint32_t,
    pub pBlockSizeList: uint32_t,
}
impl ::core::default::Default for _SAL_ADC_DMA_USER_DEF_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type SAL_ADC_DMA_USER_DEF = _SAL_ADC_DMA_USER_DEF_;
pub type PSAL_ADC_DMA_USER_DEF = *mut _SAL_ADC_DMA_USER_DEF_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _SAL_ADC_HND_ {
    pub DevNum: uint8_t,
    pub PinMux: uint8_t,
    pub OpType: uint8_t,
    pub DevSts: uint8_t,
    pub ADCExd: uint32_t,
    pub ErrType: uint32_t,
    pub TimeOut: uint32_t,
    pub pInitDat: PHAL_ADC_INIT_DAT,
    pub pRXBuf: PSAL_ADC_TRANSFER_BUF,
    pub pUserCB: PSAL_ADC_USER_CB,
}
impl ::core::default::Default for _SAL_ADC_HND_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type SAL_ADC_HND = _SAL_ADC_HND_;
pub type PSAL_ADC_HND = *mut _SAL_ADC_HND_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _SAL_ADC_HND_PRIV_ {
    pub ppSalADCHnd: *mut *mut ::ctypes::c_void,
    pub SalADCHndPriv: SAL_ADC_HND,
}
impl ::core::default::Default for _SAL_ADC_HND_PRIV_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type SAL_ADC_HND_PRIV = _SAL_ADC_HND_PRIV_;
pub type PSAL_ADC_HND_PRIV = *mut _SAL_ADC_HND_PRIV_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _SAL_ADC_MNGT_ADPT_ {
    pub pSalHndPriv: PSAL_ADC_HND_PRIV,
    pub pHalInitDat: PHAL_ADC_INIT_DAT,
    pub pHalOp: PHAL_ADC_OP,
    pub pHalOpInit: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                    *mut ::ctypes::c_void)>,
    pub pIrqHnd: PIRQ_HANDLE,
    pub pSalIrqFunc: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                     *mut ::ctypes::c_void)>,
    pub pDMAConf: PSAL_ADC_DMA_USER_DEF,
    pub pHalGdmaAdp: PHAL_GDMA_ADAPTER,
    pub pHalGdmaOp: PHAL_GDMA_OP,
    pub pIrqGdmaHnd: PIRQ_HANDLE,
    pub pHalGdmaOpInit: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                        *mut ::ctypes::c_void)>,
    pub pUserCB: PSAL_ADC_USER_CB,
    pub pSalDMAIrqFunc: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                        *mut ::ctypes::c_void)>,
}
impl ::core::default::Default for _SAL_ADC_MNGT_ADPT_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type SAL_ADC_MNGT_ADPT = _SAL_ADC_MNGT_ADPT_;
pub type PSAL_ADC_MNGT_ADPT = *mut _SAL_ADC_MNGT_ADPT_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _A2N_CATCH_W_ {
    pub A2NCatchRPage: uint8_t,
    pub A2NCatchWData: [uint32_t; 4usize],
}
impl ::core::default::Default for _A2N_CATCH_W_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type A2N_CATCH_W_QUEUE = _A2N_CATCH_W_;
pub type PA2N_CATCH_W_QUEUE = *mut _A2N_CATCH_W_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _A2N_MAILBOX_Q_ {
    pub Length: uint8_t,
    pub Response: uint8_t,
    pub Content: [uint32_t; 5usize],
}
impl ::core::default::Default for _A2N_MAILBOX_Q_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type A2N_MAILBOX_Q = _A2N_MAILBOX_Q_;
pub type PA2N_MAILBOX_Q = *mut _A2N_MAILBOX_Q_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _N2A_CATCH_R_ {
    pub Vaild: uint8_t,
    pub N2ACatchRPage: uint8_t,
    pub N2ACatchRData: [uint32_t; 4usize],
}
impl ::core::default::Default for _N2A_CATCH_R_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type N2A_CATCH_R_QUEUE = _N2A_CATCH_R_;
pub type PN2A_CATCH_R_QUEUE = *mut _N2A_CATCH_R_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _N2A_R_ {
    pub Vaild: uint8_t,
    pub N2ARPage: uint8_t,
}
impl ::core::default::Default for _N2A_R_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type N2A_R_QUEUE = _N2A_R_;
pub type PN2A_R_QUEUE = *mut _N2A_R_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _N2A_W_ {
    pub Vaild: uint8_t,
    pub N2AWPage: uint8_t,
    pub N2AWData: uint32_t,
}
impl ::core::default::Default for _N2A_W_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type N2A_W_QUEUE = _N2A_W_;
pub type PN2A_W_QUEUE = *mut _N2A_W_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _NFC_ADAPTER_ {
    pub Function: uint8_t,
    pub NFCIsr: uint32_t,
    pub N2ABoxOpen: uint8_t,
    pub A2NSeq: uint8_t,
    pub VeriSema: *mut ::ctypes::c_void,
    pub NFCTask: *mut ::ctypes::c_void,
    pub A2NWMailBox: uint8_t,
    pub A2NWQRIdx: uint8_t,
    pub A2NWQWIdx: uint8_t,
    pub A2NMAILQ: [A2N_MAILBOX_Q; 10usize],
    pub TaskStop: uint8_t,
    pub nfc_obj: *mut ::ctypes::c_void,
}
impl ::core::default::Default for _NFC_ADAPTER_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type NFC_ADAPTER = _NFC_ADAPTER_;
pub type PNFC_ADAPTER = *mut _NFC_ADAPTER_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _N2A_CMD_ {
    TAG_READ = 0,
    TAG_WRITE = 1,
    CATCH_READ_DATA = 2,
    NFC_R_PRESENT = 4,
    N2A_MAILBOX_STATE = 5,
    EXT_CLK_REQ = 6,
    MAX_N2ACMD = 7,
}
pub type N2A_CMD = _N2A_CMD_;
pub type PN2A_CMD = *mut _N2A_CMD_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _A2N_CMD_ {
    TAG_READ_DATA = 0,
    CATCH_READ = 2,
    CATCH_WRITE = 3,
    A2N_MAILBOX_STATE = 4,
    CONFIRM_N2A_BOX_STATE = 5,
    EXT_CLK_RSP = 6,
    MAX_A2NCMD = 7,
}
pub type A2N_CMD = _A2N_CMD_;
pub type PA2N_CMD = *mut _A2N_CMD_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _NFC_HAL_EVENT_ {
    NFC_HAL_READER_PRESENT = 1,
    NFC_HAL_READ = 2,
    NFC_HAL_WRITE = 4,
    NFC_HAL_ERR = 8,
    NFC_HAL_CACHE_RD = 16,
}
pub type NFC_CB_EVENT = _NFC_HAL_EVENT_;
pub type PNFC_CB_EVENT = *mut _NFC_HAL_EVENT_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _WDG_REG_ {
    pub WdgScalar: uint16_t,
    pub WdgEnByte: uint8_t,
    pub _bindgen_bitfield_1_: uint8_t,
    pub _bindgen_bitfield_2_: uint8_t,
    pub _bindgen_bitfield_3_: uint8_t,
    pub _bindgen_bitfield_4_: uint8_t,
    pub _bindgen_bitfield_5_: uint8_t,
}
impl ::core::default::Default for _WDG_REG_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type WDG_REG = _WDG_REG_;
pub type PWDG_REG = *mut _WDG_REG_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _WDG_ADAPTER_ {
    pub Ctrl: WDG_REG,
    pub IrqHandle: IRQ_HANDLE,
    pub WdgGTimer: TIMER_ADAPTER,
    pub UserCallback: ::core::option::Option<extern "C" fn(callback_id:
                                                               uint32_t)>,
    pub callback_id: uint32_t,
}
impl ::core::default::Default for _WDG_ADAPTER_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type WDG_ADAPTER = _WDG_ADAPTER_;
pub type PWDG_ADAPTER = *mut _WDG_ADAPTER_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _WDG_CNTLMT_ {
    CNT1H = 0,
    CNT3H = 1,
    CNT7H = 2,
    CNTFH = 3,
    CNT1FH = 4,
    CNT3FH = 5,
    CNT7FH = 6,
    CNTFFH = 7,
    CNT1FFH = 8,
    CNT3FFH = 9,
    CNT7FFH = 10,
    CNTFFFH = 11,
}
pub type WDG_CNTLMT = _WDG_CNTLMT_;
pub type PWDG_CNTLMT = *mut _WDG_CNTLMT_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum _WDG_MODE_ { INT_MODE = 0, RESET_MODE = 1, }
pub type WDG_MODE = _WDG_MODE_;
pub type PWDG_MODE = *mut _WDG_MODE_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _USB_TX_DESC {
    pub _bindgen_bitfield_1_: uint32_t,
    pub _bindgen_bitfield_2_: uint32_t,
    pub _bindgen_bitfield_3_: uint32_t,
    pub _bindgen_bitfield_4_: uint32_t,
    pub _bindgen_bitfield_5_: uint32_t,
    pub rsvd1: uint32_t,
    pub rsvd2: uint32_t,
    pub rsvd3: uint32_t,
    pub rsvd4: uint32_t,
}
impl ::core::default::Default for _USB_TX_DESC {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type USB_TX_DESC = _USB_TX_DESC;
pub type PUSB_TX_DESC = *mut _USB_TX_DESC;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _USB_TX_DESC_MW {
    pub _bindgen_bitfield_1_: uint32_t,
    pub _bindgen_bitfield_2_: uint32_t,
    pub _bindgen_bitfield_3_: uint32_t,
    pub _bindgen_bitfield_4_: uint32_t,
    pub _bindgen_bitfield_5_: uint32_t,
    pub _bindgen_bitfield_6_: uint32_t,
    pub start_addr: uint32_t,
    pub _bindgen_bitfield_7_: uint32_t,
    pub _bindgen_bitfield_8_: uint32_t,
    pub rsvd3: uint32_t,
    pub rsvd4: uint32_t,
}
impl ::core::default::Default for _USB_TX_DESC_MW {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type USB_TX_DESC_MW = _USB_TX_DESC_MW;
pub type PUSB_TX_DESC_MW = *mut _USB_TX_DESC_MW;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _USB_TX_DESC_MR {
    pub _bindgen_bitfield_1_: uint32_t,
    pub _bindgen_bitfield_2_: uint32_t,
    pub _bindgen_bitfield_3_: uint32_t,
    pub _bindgen_bitfield_4_: uint32_t,
    pub _bindgen_bitfield_5_: uint32_t,
    pub start_addr: uint32_t,
    pub _bindgen_bitfield_6_: uint32_t,
    pub _bindgen_bitfield_7_: uint32_t,
    pub rsvd3: uint32_t,
    pub rsvd4: uint32_t,
}
impl ::core::default::Default for _USB_TX_DESC_MR {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type USB_TX_DESC_MR = _USB_TX_DESC_MR;
pub type PUSB_TX_DESC_MR = *mut _USB_TX_DESC_MR;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _USB_TX_DESC_MS {
    pub _bindgen_bitfield_1_: uint32_t,
    pub _bindgen_bitfield_2_: uint32_t,
    pub _bindgen_bitfield_3_: uint32_t,
    pub _bindgen_bitfield_4_: uint32_t,
    pub _bindgen_bitfield_5_: uint32_t,
    pub _bindgen_bitfield_6_: uint32_t,
    pub _bindgen_bitfield_7_: uint32_t,
    pub start_addr: uint32_t,
    pub _bindgen_bitfield_8_: uint32_t,
    pub _bindgen_bitfield_9_: uint32_t,
    pub rsvd3: uint32_t,
    pub rsvd4: uint32_t,
}
impl ::core::default::Default for _USB_TX_DESC_MS {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type USB_TX_DESC_MS = _USB_TX_DESC_MS;
pub type PUSB_TX_DESC_MS = *mut _USB_TX_DESC_MS;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _USB_TX_DESC_JS {
    pub _bindgen_bitfield_1_: uint32_t,
    pub _bindgen_bitfield_2_: uint32_t,
    pub _bindgen_bitfield_3_: uint32_t,
    pub _bindgen_bitfield_4_: uint32_t,
    pub _bindgen_bitfield_5_: uint32_t,
    pub start_fun: uint32_t,
    pub rsvd2: uint32_t,
    pub rsvd3: uint32_t,
    pub rsvd4: uint32_t,
}
impl ::core::default::Default for _USB_TX_DESC_JS {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type USB_TX_DESC_JS = _USB_TX_DESC_JS;
pub type PUSB_TX_DESC_JS = *mut _USB_TX_DESC_JS;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _USB_RX_DESC {
    pub _bindgen_bitfield_1_: uint32_t,
    pub _bindgen_bitfield_2_: uint32_t,
    pub _bindgen_bitfield_3_: uint32_t,
    pub _bindgen_bitfield_4_: uint32_t,
    pub _bindgen_bitfield_5_: uint32_t,
    pub _bindgen_bitfield_6_: uint32_t,
    pub _bindgen_bitfield_7_: uint32_t,
    pub rsvd2: uint32_t,
    pub rsvd3: uint32_t,
    pub rsvd4: uint32_t,
    pub rsvd5: uint32_t,
}
impl ::core::default::Default for _USB_RX_DESC {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type USB_RX_DESC = _USB_RX_DESC;
pub type PUSB_RX_DESC = *mut _USB_RX_DESC;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _USB_RX_DESC_MR {
    pub _bindgen_bitfield_1_: uint32_t,
    pub _bindgen_bitfield_2_: uint32_t,
    pub _bindgen_bitfield_3_: uint32_t,
    pub _bindgen_bitfield_4_: uint32_t,
    pub _bindgen_bitfield_5_: uint32_t,
    pub start_addr: uint32_t,
    pub rsvd2: uint32_t,
    pub rsvd3: uint32_t,
    pub rsvd4: uint32_t,
}
impl ::core::default::Default for _USB_RX_DESC_MR {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type USB_RX_DESC_MR = _USB_RX_DESC_MR;
pub type PUSB_RX_DESC_MR = *mut _USB_RX_DESC_MR;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _USB_RX_DESC_MW {
    pub _bindgen_bitfield_1_: uint32_t,
    pub _bindgen_bitfield_2_: uint32_t,
    pub _bindgen_bitfield_3_: uint32_t,
    pub _bindgen_bitfield_4_: uint32_t,
    pub _bindgen_bitfield_5_: uint32_t,
    pub start_addr: uint32_t,
    pub _bindgen_bitfield_6_: uint32_t,
    pub _bindgen_bitfield_7_: uint32_t,
    pub _bindgen_bitfield_8_: uint32_t,
    pub rsvd3: uint32_t,
    pub rsvd4: uint32_t,
}
impl ::core::default::Default for _USB_RX_DESC_MW {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type USB_RX_DESC_MW = _USB_RX_DESC_MW;
pub type PUSB_RX_DESC_MW = *mut _USB_RX_DESC_MW;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _USB_RX_DESC_MS {
    pub _bindgen_bitfield_1_: uint32_t,
    pub _bindgen_bitfield_2_: uint32_t,
    pub _bindgen_bitfield_3_: uint32_t,
    pub _bindgen_bitfield_4_: uint32_t,
    pub _bindgen_bitfield_5_: uint32_t,
    pub start_addr: uint32_t,
    pub _bindgen_bitfield_6_: uint32_t,
    pub _bindgen_bitfield_7_: uint32_t,
    pub _bindgen_bitfield_8_: uint32_t,
    pub rsvd3: uint32_t,
    pub rsvd4: uint32_t,
}
impl ::core::default::Default for _USB_RX_DESC_MS {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type USB_RX_DESC_MS = _USB_RX_DESC_MS;
pub type PUSB_RX_DESC_MS = *mut _USB_RX_DESC_MS;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _USB_RX_DESC_FS {
    pub _bindgen_bitfield_1_: uint32_t,
    pub _bindgen_bitfield_2_: uint32_t,
    pub _bindgen_bitfield_3_: uint32_t,
    pub _bindgen_bitfield_4_: uint32_t,
    pub _bindgen_bitfield_5_: uint32_t,
    pub rsvd2: uint32_t,
    pub rsvd3: uint32_t,
    pub rsvd4: uint32_t,
    pub rsvd5: uint32_t,
}
impl ::core::default::Default for _USB_RX_DESC_FS {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type USB_RX_DESC_FS = _USB_RX_DESC_FS;
pub type PUSB_RX_DESC_FS = *mut _USB_RX_DESC_FS;
pub const LCR_STOP_1B: LOG_UART_LINE_CTRL = LOG_UART_LINE_CTRL::LCR_DLS_5B;
pub const LCR_PARITY_NONE: LOG_UART_LINE_CTRL =
    LOG_UART_LINE_CTRL::LCR_DLS_5B;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum LOG_UART_LINE_CTRL {
    LCR_DLS_5B = 0,
    LCR_DLS_6B = 1,
    LCR_DLS_7B = 2,
    LCR_DLS_8B = 3,
    LCR_STOP_2B = 4,
    LCR_PARITY_ODD = 8,
    LCR_PARITY_EVEN = 24,
    LCR_BC = 64,
    LCR_DLAB = 128,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum LOG_UART_INT_ID {
    IIR_MODEM_STATUS = 0,
    IIR_NO_PENDING = 1,
    IIR_THR_EMPTY = 2,
    IIR_RX_RDY = 4,
    IIR_RX_LINE_STATUS = 6,
    IIR_BUSY = 7,
    IIR_CHAR_TIMEOUT = 12,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum LOG_UART_INT_EN {
    IER_ERBFI = 1,
    IER_ETBEI = 2,
    IER_ELSI = 4,
    IER_EDSSI = 8,
    IER_PTIME = 128,
}
pub const LSR_FIFOF: LOG_UART_LINE_STATUS = LOG_UART_LINE_STATUS::LSR_THRE;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum LOG_UART_LINE_STATUS {
    LSR_DR = 1,
    LSR_OE = 2,
    LSR_PE = 4,
    LSR_FE = 8,
    LSR_BI = 16,
    LSR_THRE = 32,
    LSR_TEMT = 64,
    LSR_RFE = 128,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum Enum_Unnamed8 { LOG_UART_RST_TX_FIFO = 1, LOG_UART_RST_RX_FIFO = 2, }
pub const FCR_TX_TRIG_MASK: LOG_UART_FIFO_CTRL =
    LOG_UART_FIFO_CTRL::FCR_TX_TRIG_HF;
pub const FCR_RX_TRIG_1CH: LOG_UART_FIFO_CTRL =
    LOG_UART_FIFO_CTRL::FCR_TX_TRIG_EMP;
pub const FCR_RX_TRIG_MASK: LOG_UART_FIFO_CTRL =
    LOG_UART_FIFO_CTRL::FCR_RX_TRIG_AF;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum LOG_UART_FIFO_CTRL {
    FCR_FIFO_EN = 1,
    FCR_RST_RX = 2,
    FCR_RST_TX = 4,
    FCR_TX_TRIG_EMP = 0,
    FCR_TX_TRIG_2CH = 16,
    FCR_TX_TRIG_QF = 32,
    FCR_TX_TRIG_HF = 48,
    FCR_RX_TRIG_QF = 64,
    FCR_RX_TRIG_HF = 128,
    FCR_RX_TRIG_AF = 192,
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _HAL_LOG_UART_ADAPTER_ {
    pub BaudRate: uint32_t,
    pub FIFOControl: uint32_t,
    pub IntEnReg: uint32_t,
    pub Parity: uint8_t,
    pub Stop: uint8_t,
    pub DataLength: uint8_t,
    pub LineStatus: uint8_t,
    pub TxCount: uint32_t,
    pub RxCount: uint32_t,
    pub pTxBuf: *mut uint8_t,
    pub pRxBuf: *mut uint8_t,
    pub pTxStartAddr: *mut uint8_t,
    pub pRxStartAddr: *mut uint8_t,
    pub IrqHandle: IRQ_HANDLE,
    pub LineStatusCallback: ::core::option::Option<unsafe extern "C" fn(para:
                                                                            *mut ::ctypes::c_void,
                                                                        status:
                                                                            uint8_t)>,
    pub TxCompCallback: ::core::option::Option<unsafe extern "C" fn(para:
                                                                        *mut ::ctypes::c_void)>,
    pub RxCompCallback: ::core::option::Option<unsafe extern "C" fn(para:
                                                                        *mut ::ctypes::c_void)>,
    pub LineStatusCbPara: *mut ::ctypes::c_void,
    pub TxCompCbPara: *mut ::ctypes::c_void,
    pub RxCompCbPara: *mut ::ctypes::c_void,
    pub api_irq_handler: ::core::option::Option<extern "C" fn(id: uint32_t,
                                                              event:
                                                                  LOG_UART_INT_ID)>,
    pub api_irq_id: uint32_t,
}
impl ::core::default::Default for _HAL_LOG_UART_ADAPTER_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type HAL_LOG_UART_ADAPTER = _HAL_LOG_UART_ADAPTER_;
pub type PHAL_LOG_UART_ADAPTER = *mut _HAL_LOG_UART_ADAPTER_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _TX_DESC_FMT_ {
    pub dw1: uint32_t,
    pub addr: uint32_t,
    pub dw2: uint32_t,
    pub dw3: uint32_t,
    pub dw4: uint32_t,
}
impl ::core::default::Default for _TX_DESC_FMT_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type TX_DESC_FMT = _TX_DESC_FMT_;
pub type PTX_DESC_FMT = *mut _TX_DESC_FMT_;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _RX_DESC_FMT_ {
    pub dw1: uint32_t,
    pub addr: uint32_t,
    pub dw2: uint32_t,
    pub dw3: uint32_t,
}
impl ::core::default::Default for _RX_DESC_FMT_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type RX_DESC_FMT = _RX_DESC_FMT_;
pub type PRX_DESC_FMT = *mut _RX_DESC_FMT_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum EthernetEventType {
    ETH_TXDONE = 0,
    ETH_RXDONE = 1,
    ETH_LINKUP = 2,
    ETH_LINKDOWN = 3,
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct _HAL_ETHER_ADAPTER_ {
    pub IrqHandle: IRQ_HANDLE,
    pub InterruptMask: uint32_t,
    pub tx_desc_num: uint8_t,
    pub rx_desc_num: uint8_t,
    pub TxDescAddr: *mut uint8_t,
    pub RxDescAddr: *mut uint8_t,
    pub pTxPktBuf: *mut uint8_t,
    pub pRxPktBuf: *mut uint8_t,
    pub CallBack: ::core::option::Option<extern "C" fn(Event: uint32_t,
                                                       Data: uint32_t)>,
}
impl ::core::default::Default for _HAL_ETHER_ADAPTER_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type HAL_ETHER_ADAPTER = _HAL_ETHER_ADAPTER_;
pub type PHAL_ETHER_ADAPTER = *mut _HAL_ETHER_ADAPTER_;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum PortName {
    PortA = 0,
    PortB = 1,
    PortC = 2,
    PortD = 3,
    PortE = 4,
    PortF = 5,
    PortG = 6,
    PortH = 7,
    PortI = 8,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum DACName { DAC_0 = 0, DAC_1 = 1, }
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum GPIO_PORT {
    PORT_A = 0,
    PORT_B = 1,
    PORT_C = 2,
    PORT_D = 3,
    PORT_E = 4,
    PORT_F = 5,
    PORT_G = 6,
    PORT_H = 7,
    PORT_I = 8,
    PORT_J = 9,
    PORT_K = 10,
    PORT_V = 11,
    PORT_U = 12,
    PORT_MAX = 13,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum PinDirection { PIN_INPUT = 0, PIN_OUTPUT = 1, }
pub const LED1: PinName = PinName::PB_4;
pub const LED2: PinName = PinName::PB_5;
pub const LED3: PinName = PinName::PB_6;
pub const LED4: PinName = PinName::PB_7;
pub const USER_BUTTON: PinName = PinName::PA_3;
pub const SERIAL_TX: PinName = PinName::PA_3;
pub const SERIAL_RX: PinName = PinName::PA_0;
pub const USBTX: PinName = PinName::PA_7;
pub const USBRX: PinName = PinName::PA_6;
pub const I2C_SCL: PinName = PinName::PC_5;
pub const I2C_SDA: PinName = PinName::PC_4;
pub const SPI_MOSI: PinName = PinName::PC_2;
pub const SPI_MISO: PinName = PinName::PC_3;
pub const SPI_SCK: PinName = PinName::PC_1;
pub const SPI_CS: PinName = PinName::PC_0;
pub const PWM_OUT: PinName = PinName::PD_4;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum PinName {
    PA_0 = 0,
    PA_1 = 1,
    PA_2 = 2,
    PA_3 = 3,
    PA_4 = 4,
    PA_5 = 5,
    PA_6 = 6,
    PA_7 = 7,
    PB_0 = 16,
    PB_1 = 17,
    PB_2 = 18,
    PB_3 = 19,
    PB_4 = 20,
    PB_5 = 21,
    PB_6 = 22,
    PB_7 = 23,
    PC_0 = 32,
    PC_1 = 33,
    PC_2 = 34,
    PC_3 = 35,
    PC_4 = 36,
    PC_5 = 37,
    PC_6 = 38,
    PC_7 = 39,
    PC_8 = 40,
    PC_9 = 41,
    PD_0 = 48,
    PD_1 = 49,
    PD_2 = 50,
    PD_3 = 51,
    PD_4 = 52,
    PD_5 = 53,
    PD_6 = 54,
    PD_7 = 55,
    PD_8 = 56,
    PD_9 = 57,
    PE_0 = 64,
    PE_1 = 65,
    PE_2 = 66,
    PE_3 = 67,
    PE_4 = 68,
    PE_5 = 69,
    PE_6 = 70,
    PE_7 = 71,
    PE_8 = 72,
    PE_9 = 73,
    PE_A = 74,
    PF_0 = 80,
    PF_1 = 81,
    PF_2 = 82,
    PF_3 = 83,
    PF_4 = 84,
    PF_5 = 85,
    PG_0 = 96,
    PG_1 = 97,
    PG_2 = 98,
    PG_3 = 99,
    PG_4 = 100,
    PG_5 = 101,
    PG_6 = 102,
    PG_7 = 103,
    PH_0 = 112,
    PH_1 = 113,
    PH_2 = 114,
    PH_3 = 115,
    PH_4 = 116,
    PH_5 = 117,
    PH_6 = 118,
    PH_7 = 119,
    PI_0 = 128,
    PI_1 = 129,
    PI_2 = 130,
    PI_3 = 131,
    PI_4 = 132,
    PI_5 = 133,
    PI_6 = 134,
    PI_7 = 135,
    PJ_0 = 144,
    PJ_1 = 145,
    PJ_2 = 146,
    PJ_3 = 147,
    PJ_4 = 148,
    PJ_5 = 149,
    PJ_6 = 150,
    PK_0 = 160,
    PK_1 = 161,
    PK_2 = 162,
    PK_3 = 163,
    PK_4 = 164,
    PK_5 = 165,
    PK_6 = 166,
    AD_1 = 177,
    AD_2 = 178,
    AD_3 = 179,
    DA_0 = 192,
    DA_1 = 193,
    NC = 4294967295,
}
pub const PullDefault: PinMode = PinMode::PullNone;
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum PinMode { PullNone = 0, PullUp = 1, PullDown = 2, OpenDrain = 3, }
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct gpio_irq_s {
    pub pin: PinName,
    pub event: uint32_t,
    pub hal_pin: HAL_GPIO_PIN,
    pub hal_port_num: uint8_t,
    pub hal_pin_num: uint8_t,
}
impl ::core::default::Default for gpio_irq_s {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type gpio_irq_t = gpio_irq_s;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct gpio_s {
    pub pin: PinName,
    pub mode: PinMode,
    pub direction: PinDirection,
    pub hal_pin: HAL_GPIO_PIN,
    pub hal_port_num: uint8_t,
    pub hal_pin_num: uint8_t,
}
impl ::core::default::Default for gpio_s {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type gpio_t = gpio_s;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct port_s {
    pub port: PortName,
    pub mask: uint32_t,
    pub direction: PinDirection,
    pub pin_def: *mut uint8_t,
}
impl ::core::default::Default for port_s {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct serial_s {
    pub hal_uart_op: HAL_RUART_OP,
    pub hal_uart_adp: HAL_RUART_ADAPTER,
    pub uart_gdma_cfg: UART_DMA_CONFIG,
    pub uart_gdma_adp_tx: HAL_GDMA_ADAPTER,
    pub uart_gdma_adp_rx: HAL_GDMA_ADAPTER,
    pub gdma_multiblk_list_tx: UART_DMA_MULTIBLK,
    pub gdma_multiblk_list_rx: UART_DMA_MULTIBLK,
    pub tx_len: uint32_t,
    pub rx_len: uint32_t,
}
impl ::core::default::Default for serial_s {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct log_uart_s {
    pub log_hal_uart: HAL_LOG_UART_ADAPTER,
}
impl ::core::default::Default for log_uart_s {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct pwmout_s {
    pub pwm_idx: uint8_t,
    pub pin_sel: uint8_t,
    pub period: uint32_t,
    pub pulse: uint32_t,
    pub pwm_hal_adp: HAL_PWM_ADAPTER,
}
impl ::core::default::Default for pwmout_s {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct i2c_s {
    pub SalI2CMngtAdpt: SAL_I2C_MNGT_ADPT,
    pub SalI2CHndPriv: SAL_I2C_HND_PRIV,
    pub HalI2CInitData: HAL_I2C_INIT_DAT,
    pub HalI2COp: HAL_I2C_OP,
    pub I2CIrqHandleDat: IRQ_HANDLE,
    pub HalI2CTxGdmaAdpt: HAL_GDMA_ADAPTER,
    pub HalI2CRxGdmaAdpt: HAL_GDMA_ADAPTER,
    pub HalI2CGdmaOp: HAL_GDMA_OP,
    pub I2CTxGdmaIrqHandleDat: IRQ_HANDLE,
    pub I2CRxGdmaIrqHandleDat: IRQ_HANDLE,
    pub SalI2CUserCB: SAL_I2C_USER_CB,
    pub SalI2CUserCBAdpt: [SAL_I2C_USERCB_ADPT; 11usize],
    pub SalI2CDmaUserDef: SAL_I2C_DMA_USER_DEF,
}
impl ::core::default::Default for i2c_s {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct flash_s {
    pub SpicInitPara: SPIC_INIT_PARA,
    pub Length: uint32_t,
}
impl ::core::default::Default for flash_s {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct analogin_s {
    pub SalADCMngtAdpt: SAL_ADC_MNGT_ADPT,
    pub SalADCHndPriv: SAL_ADC_HND_PRIV,
    pub HalADCInitData: HAL_ADC_INIT_DAT,
    pub HalADCOp: HAL_ADC_OP,
    pub ADCIrqHandleDat: IRQ_HANDLE,
    pub HalADCGdmaAdpt: HAL_GDMA_ADAPTER,
    pub HalADCGdmaOp: HAL_GDMA_OP,
    pub ADCGdmaIrqHandleDat: IRQ_HANDLE,
    pub SalADCUserCB: SAL_ADC_USER_CB,
    pub SalADCUserCBAdpt: [SAL_ADC_USERCB_ADPT; 10usize],
}
impl ::core::default::Default for analogin_s {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct nfctag_s {
    pub NFCAdapter: NFC_ADAPTER,
    pub nfc_rd_cb: *mut ::ctypes::c_void,
    pub rd_cb_arg: *mut ::ctypes::c_void,
    pub nfc_wr_cb: *mut ::ctypes::c_void,
    pub wr_cb_arg: *mut ::ctypes::c_void,
    pub nfc_ev_cb: *mut ::ctypes::c_void,
    pub ev_cb_arg: *mut ::ctypes::c_void,
    pub nfc_cache_rd_cb: *mut ::ctypes::c_void,
    pub cache_read_cb_arg: *mut ::ctypes::c_void,
    pub event_mask: ::ctypes::c_uint,
    pub pwr_status: ::ctypes::c_int,
}
impl ::core::default::Default for nfctag_s {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct gtimer_s {
    pub hal_gtimer_adp: TIMER_ADAPTER,
    pub handler: *mut ::ctypes::c_void,
    pub hid: uint32_t,
    pub timer_id: uint8_t,
    pub is_periodcal: uint8_t,
}
impl ::core::default::Default for gtimer_s {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct i2s_s {
    pub I2SAdapter: HAL_I2S_ADAPTER,
    pub InitDat: HAL_I2S_INIT_DAT,
    pub sampling_rate: uint8_t,
    pub channel_num: uint8_t,
    pub word_length: uint8_t,
    pub direction: uint8_t,
}
impl ::core::default::Default for i2s_s {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct dac_s {
    pub DACpara: HAL_DAC_INIT_DAT,
}
impl ::core::default::Default for dac_s {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum SerialParity {
    ParityNone = 0,
    ParityOdd = 1,
    ParityEven = 2,
    ParityForced1 = 3,
    ParityForced0 = 4,
}
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum SerialIrq { RxIrq = 0, TxIrq = 1, }
#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum FlowControl {
    FlowControlNone = 0,
    FlowControlRTS = 1,
    FlowControlCTS = 2,
    FlowControlRTSCTS = 3,
}
pub type uart_irq_handler =
    ::core::option::Option<extern "C" fn(id: uint32_t, event: SerialIrq)>;
pub type serial_t = serial_s;
extern "C" {
    pub static mut HalTimerOp: HAL_TIMER_OP;
    pub static mut PwrAdapter: Power_Mgn;
    pub static mut ConfigDebugErr: uint32_t;
    pub static mut ConfigDebugInfo: uint32_t;
    pub static mut ConfigDebugWarn: uint32_t;
    pub static mut CfgSysDebugErr: uint32_t;
    pub static mut CfgSysDebugInfo: uint32_t;
    pub static mut CfgSysDebugWarn: uint32_t;
    pub static mut ITM_RxBuffer: int32_t;
    pub static _HalGdmaOp: HAL_GDMA_OP;
    pub static mut GDMA_Chnl_Option: [HAL_GDMA_CHNL; 0usize];
    pub static mut GDMA_Multi_Block_Chnl_Option: [HAL_GDMA_CHNL; 0usize];
    pub static mut HalGdmaChnlEn: [uint16_t; 6usize];
    pub static mut _pHAL_Gpio_Adapter: PHAL_GPIO_ADAPTER;
    pub static mut SSI_DBG_CONFIG: uint32_t;
    pub static mut SPI0_IS_AS_SLAVE: uint8_t;
    pub static _HalRuartOp: HAL_RUART_OP;
}
extern "C" {
    pub fn HalPinCtrlRtl8195A(Function: uint32_t, PinLocation: uint32_t,
                              Operation: BOOL) -> uint8_t;
    pub fn GpioFunctionChk(chip_pin: uint32_t, Operation: uint8_t) -> uint8_t;
    pub fn FunctionChk(Function: uint32_t, PinLocation: uint32_t) -> uint8_t;
    pub fn SpicFlashInitRtl8195A(SpicBitMode: uint8_t) -> BOOLEAN;
    pub fn InitWDGIRQ();
    pub fn HalDelayUs(us: uint32_t) -> uint32_t;
    pub fn HalGetCpuClk() -> uint32_t;
    pub fn HalGetRomInfo() -> uint8_t;
    pub fn _memset(s: *mut ::ctypes::c_void, c: ::ctypes::c_int, n: SIZE_T)
     -> *mut ::ctypes::c_void;
    pub fn _memcpy(s1: *mut ::ctypes::c_void, s2: *const ::ctypes::c_void,
                   n: SIZE_T) -> *mut ::ctypes::c_void;
    pub fn _memcmp(av: *const ::ctypes::c_void, bv: *const ::ctypes::c_void,
                   len: SIZE_T) -> ::ctypes::c_int;
    pub fn _strlen(s: *const ::ctypes::c_char) -> SIZE_T;
    pub fn _strcmp(cs: *const ::ctypes::c_char, ct: *const ::ctypes::c_char)
     -> ::ctypes::c_int;
    pub fn HalSetResetCause(reason: HAL_RESET_REASON);
    pub fn HalGetResetCause() -> HAL_RESET_REASON;
    pub fn VectorTableInitRtl8195A(StackP: uint32_t);
    pub fn VectorTableInitForOSRtl8195A(PortSVC: *mut ::ctypes::c_void,
                                        PortPendSVH: *mut ::ctypes::c_void,
                                        PortSysTick: *mut ::ctypes::c_void);
    pub fn VectorIrqRegisterRtl8195A(pIrqHandle: PIRQ_HANDLE) -> BOOL;
    pub fn VectorIrqUnRegisterRtl8195A(pIrqHandle: PIRQ_HANDLE) -> BOOL;
    pub fn VectorIrqEnRtl8195A(pIrqHandle: PIRQ_HANDLE);
    pub fn VectorIrqDisRtl8195A(pIrqHandle: PIRQ_HANDLE);
    pub fn HalPeripheralIntrHandle();
    pub fn HalLogUartInit(UartAdapter: LOG_UART_ADAPTER) -> uint32_t;
    pub fn HalSerialPutcRtl8195a(c: uint8_t);
    pub fn HalSerialGetcRtl8195a(PullMode: BOOL) -> uint8_t;
    pub fn HalSerialGetIsrEnRegRtl8195a() -> uint32_t;
    pub fn HalSerialSetIrqEnRegRtl8195a(SetValue: uint32_t);
    pub fn SpiFlashAppV02(Data: *mut ::ctypes::c_void);
    pub fn SpicInitRtl8195AV02(InitBaudRate: uint8_t, SpicBitMode: uint8_t);
    pub fn SpicEraseFlashRtl8195AV02();
    pub fn SpicLoadInitParaFromClockRtl8195AV02(CpuClkMode: uint8_t,
                                                BaudRate: uint8_t,
                                                pSpicInitPara:
                                                    PSPIC_INIT_PARA);
    pub fn SpicBlockEraseFlashRtl8195A(Address: uint32_t);
    pub fn SpicSectorEraseFlashRtl8195A(Address: uint32_t);
    pub fn SpicDieEraseFlashRtl8195A(Address: uint32_t);
    pub fn SpicWriteProtectFlashRtl8195A(Protect: uint32_t);
    pub fn SpicWaitWipDoneRefinedRtl8195A(SpicInitPara: SPIC_INIT_PARA);
    pub fn SpicWaitOperationDoneRtl8195A(SpicInitPara: SPIC_INIT_PARA);
    pub fn SpicRxCmdRefinedRtl8195A(cmd: uint8_t,
                                    SpicInitPara: SPIC_INIT_PARA);
    pub fn SpicGetFlashStatusRefinedRtl8195A(SpicInitPara: SPIC_INIT_PARA)
     -> uint8_t;
    pub fn SpicInitRefinedRtl8195A(InitBaudRate: uint8_t,
                                   SpicBitMode: uint8_t);
    pub fn SpicWaitWipRtl8195A() -> uint32_t;
    pub fn SpicOneBitCalibrationRtl8195A(SysCpuClk: uint8_t) -> uint32_t;
    pub fn SpicDisableRtl8195A();
    pub fn SpicDeepPowerDownFlashRtl8195A();
    pub fn SpicUserProgramRtl8195A(data: *mut uint8_t,
                                   SpicInitPara: SPIC_INIT_PARA,
                                   addr: uint32_t, LengthInfo: *mut uint32_t);
    pub fn SpicUserReadRtl8195A(Length: uint32_t, addr: uint32_t,
                                data: *mut uint8_t, BitMode: uint8_t);
    pub fn SpicUserReadFourByteRtl8195A(Length: uint32_t, addr: uint32_t,
                                        data: *mut uint32_t,
                                        BitMode: uint8_t);
    pub fn SpicReadIDRtl8195A();
    pub fn SpicSetFlashStatusRefinedRtl8195A(data: uint32_t,
                                             SpicInitPara: SPIC_INIT_PARA);
    pub fn SpicSetExtendAddrRtl8195A(data: uint32_t,
                                     SpicInitPara: SPIC_INIT_PARA);
    pub fn SpicGetExtendAddrRtl8195A(SpicInitPara: SPIC_INIT_PARA) -> uint8_t;
    pub fn SpicNVMCalLoad(BitMode: uint8_t, CpuClk: uint8_t);
    pub fn SpicNVMCalLoadAll();
    pub fn SpicNVMCalStore(BitMode: uint8_t, CpuClk: uint8_t);
    pub fn SpicInitRtl8195A(InitBaudRate: uint8_t, SpicBitMode: uint8_t);
    pub fn SpicRxCmdRtl8195A(arg1: uint8_t);
    pub fn SpicTxCmdRtl8195A(cmd: uint8_t, SpicInitPara: SPIC_INIT_PARA);
    pub fn SpicGetFlashStatusRtl8195A(SpicInitPara: SPIC_INIT_PARA)
     -> uint8_t;
    pub fn SpicSetFlashStatusRtl8195A(data: uint32_t,
                                      SpicInitPara: SPIC_INIT_PARA);
    pub fn SpicWaitBusyDoneRtl8195A();
    pub fn SpicWaitWipDoneRtl8195A(SpicInitPara: SPIC_INIT_PARA);
    pub fn SpicEraseFlashRtl8195A();
    pub fn SpicCmpDataForCalibrationRtl8195A() -> uint32_t;
    pub fn SpicLoadInitParaFromClockRtl8195A(CpuClkMode: uint8_t,
                                             BaudRate: uint8_t,
                                             pSpicInitPara: PSPIC_INIT_PARA);
    pub fn SpicTxCmdWithDataRtl8195A_V04(pSpicInitPara: *mut SPIC_INIT_PARA,
                                         cmd: uint8_t, DataPhaseLen: uint8_t,
                                         pData: *mut uint8_t);
    pub fn SpicTxFlashInstRtl8195A_V04(pSpicInitPara: *mut SPIC_INIT_PARA,
                                       cmd: uint8_t, DataPhaseLen: uint8_t,
                                       pData: *mut uint8_t);
    pub fn SpicDeepPowerDownFlashRtl8195A_V04(pSpicInitPara:
                                                  *mut SPIC_INIT_PARA);
    pub fn SpicBlockEraseFlashRtl8195A_V04(pSpicInitPara: *mut SPIC_INIT_PARA,
                                           Address: uint32_t);
    pub fn SpicSectorEraseFlashRtl8195A_V04(pSpicInitPara:
                                                *mut SPIC_INIT_PARA,
                                            Address: uint32_t);
    pub fn SpicWriteProtectFlashRtl8195A_V04(pSpicInitPara:
                                                 *mut SPIC_INIT_PARA,
                                             Protect: uint32_t);
    pub fn SpicFlashInitRtl8195A_V04(pSpicInitPara: *mut SPIC_INIT_PARA,
                                     SpicBitMode: uint8_t) -> BOOLEAN;
    pub fn SpicCalibrationRtl8195A_V04(pSpicInitPara: *mut SPIC_INIT_PARA,
                                       SpicBitMode: uint8_t,
                                       DefRdDummyCycle: uint32_t) -> uint32_t;
    pub fn SpicConfigAutoModeRtl8195A_V04(SpicBitMode: uint8_t);
    pub fn SpicWaitWipDoneRefinedRtl8195A_V04(pSpicInitPara:
                                                  *mut SPIC_INIT_PARA);
    pub fn SpicRxCmdRefinedRtl8195A_V04(pSpicInitPara: *mut SPIC_INIT_PARA,
                                        cmd: uint8_t);
    pub fn SpicGetFlashStatusRefinedRtl8195A_V04(pSpicInitPara:
                                                     *mut SPIC_INIT_PARA)
     -> uint8_t;
    pub fn SpicInitRefinedRtl8195A_V04(pSpicInitPara: *mut SPIC_INIT_PARA,
                                       InitBaudRate: uint8_t,
                                       SpicBitMode: uint8_t);
    pub fn SpicEraseFlashRefinedRtl8195A_V04(pSpicInitPara:
                                                 *mut SPIC_INIT_PARA);
    pub fn SpicSetFlashStatusRefinedRtl8195A_V04(pSpicInitPara:
                                                     *mut SPIC_INIT_PARA,
                                                 data: uint32_t);
    pub fn SpicWaitWipRtl8195A_V04(pSpicInitPara: *mut SPIC_INIT_PARA)
     -> uint32_t;
    pub fn SpicOneBitCalibrationRtl8195A_V04(pSpicInitPara:
                                                 *mut SPIC_INIT_PARA,
                                             SysCpuClk: uint8_t) -> uint32_t;
    pub fn SpicLoadInitParaFromClockRtl8195A_V04(CpuClkMode: uint8_t,
                                                 BaudRate: uint8_t,
                                                 pSpicInitPara:
                                                     PSPIC_INIT_PARA);
    pub fn SpicGetFlashFlagRtl8195A_V04(pSpicInitPara: *mut SPIC_INIT_PARA)
     -> uint8_t;
    pub fn SpicWaitOperationDoneRtl8195A_V04(pSpicInitPara:
                                                 *mut SPIC_INIT_PARA);
    pub fn SpicUserProgramRtl8195A_V04(data: *mut uint8_t,
                                       SpicInitPara: SPIC_INIT_PARA,
                                       addr: uint32_t,
                                       LengthInfo: *mut uint32_t);
    pub fn SpicUserReadRtl8195A_V04(Length: uint32_t, addr: uint32_t,
                                    data: *mut uint8_t);
    pub fn SpicUserReadFourByteRtl8195A_V04(Length: uint32_t, addr: uint32_t,
                                            data: *mut uint32_t,
                                            BitMode: uint8_t);
    pub fn SpicSetExtendAddrRtl8195A_V04(data: uint32_t,
                                         pSpicInitPara: *mut SPIC_INIT_PARA);
    pub fn SpicGetExtendAddrRtl8195A_V04(pSpicInitPara: *mut SPIC_INIT_PARA)
     -> uint8_t;
    pub fn SpicReadIDRtl8195A_V04();
    pub fn SpicDieEraseFlashRtl8195A_V04(pSpicInitPara: *mut SPIC_INIT_PARA,
                                         Address: uint32_t);
    pub fn SpicGetConfigRegRtl8195A_V04(pSpicInitPara: *mut SPIC_INIT_PARA)
     -> uint8_t;
    pub fn HalGetTimerIdRtl8195a(TimerID: *mut uint32_t) -> uint32_t;
    pub fn HalTimerInitRtl8195a(Data: *mut ::ctypes::c_void) -> BOOL;
    pub fn HalTimerReadCountRtl8195a(TimerId: uint32_t) -> uint32_t;
    pub fn HalTimerIrqClearRtl8195a(TimerId: uint32_t);
    pub fn HalTimerDisRtl8195a(TimerId: uint32_t);
    pub fn HalTimerEnRtl8195a(TimerId: uint32_t);
    pub fn HalTimerDumpRegRtl8195a(TimerId: uint32_t);
    pub fn HalTimerInitRtl8195a_Patch(Data: *mut ::ctypes::c_void)
     -> HAL_Status;
    pub fn HalTimerReadCountRtl8195a_Patch(TimerId: uint32_t) -> uint32_t;
    pub fn HalTimerReLoadRtl8195a_Patch(TimerId: uint32_t, LoadUs: uint32_t);
    pub fn HalTimerIrqEnRtl8195a(TimerId: uint32_t);
    pub fn HalTimerIrqDisRtl8195a(TimerId: uint32_t);
    pub fn HalTimerClearIsrRtl8195a(TimerId: uint32_t);
    pub fn HalTimerEnRtl8195a_Patch(TimerId: uint32_t);
    pub fn HalTimerDisRtl8195a_Patch(TimerId: uint32_t);
    pub fn HalTimerDeInitRtl8195a_Patch(Data: *mut ::ctypes::c_void);
    pub fn HalTimerOpInit_Patch(Data: *mut ::ctypes::c_void);
    pub fn HalTimerOpInitV02(Data: *mut ::ctypes::c_void);
    pub fn HalEFUSEPowerSwitch8195AROM(bWrite: uint8_t, PwrState: uint8_t,
                                       L25OutVoltage: uint8_t);
    pub fn HALEFUSEOneByteReadRAM(CtrlSetting: uint32_t, Addr: uint16_t,
                                  Data: *mut uint8_t, L25OutVoltage: uint8_t)
     -> uint32_t;
    pub fn HALEFUSEOneByteWriteRAM(CtrlSetting: uint32_t, Addr: uint16_t,
                                   Data: uint8_t, L25OutVoltage: uint8_t)
     -> uint32_t;
    pub fn ChangeSoCPwrState(RequestState: uint8_t, ReqCount: uint32_t)
     -> uint8_t;
    pub fn PrintCPU();
    pub fn WakeFromSLPPG();
    pub fn SOCPSTestApp(Data: *mut ::ctypes::c_void);
    pub fn RegPowerState(RegPwrState: REG_POWER_STATE);
    pub fn DiagPrintf(fmt: *const ::ctypes::c_char, ...) -> uint32_t;
    pub fn DiagSPrintf(buf: *mut uint8_t, fmt: *const ::ctypes::c_char, ...)
     -> uint32_t;
    pub fn prvDiagPrintf(fmt: *const ::ctypes::c_char, ...)
     -> ::ctypes::c_int;
    pub fn prvDiagSPrintf(buf: *mut ::ctypes::c_char,
                          fmt: *const ::ctypes::c_char, ...)
     -> ::ctypes::c_int;
    pub fn HalCommonInit() -> HAL_Status;
    pub fn HalGdmaOnOffRtl8195a(Data: *mut ::ctypes::c_void);
    pub fn HalGdamChInitRtl8195a(Data: *mut ::ctypes::c_void) -> BOOL;
    pub fn HalGdmaChSetingRtl8195a(Data: *mut ::ctypes::c_void) -> BOOL;
    pub fn HalGdmaChBlockSetingRtl8195a(Data: *mut ::ctypes::c_void) -> BOOL;
    pub fn HalGdmaChBlockSetingRtl8195a_Patch(Data: *mut ::ctypes::c_void)
     -> BOOL;
    pub fn HalGdmaChDisRtl8195a(Data: *mut ::ctypes::c_void);
    pub fn HalGdmaChEnRtl8195a(Data: *mut ::ctypes::c_void);
    pub fn HalGdmaChIsrEnAndDisRtl8195a(Data: *mut ::ctypes::c_void);
    pub fn HalGdmaChIsrCleanRtl8195a(Data: *mut ::ctypes::c_void) -> uint8_t;
    pub fn HalGdmaChCleanAutoSrcRtl8195a(Data: *mut ::ctypes::c_void);
    pub fn HalGdmaChCleanAutoDstRtl8195a(Data: *mut ::ctypes::c_void);
    pub fn HalGdmaQueryDArRtl8195a(Data: *mut ::ctypes::c_void) -> uint32_t;
    pub fn HalGdmaQuerySArRtl8195a(Data: *mut ::ctypes::c_void) -> uint32_t;
    pub fn HalGdmaQueryChEnRtl8195a(Data: *mut ::ctypes::c_void) -> BOOL;
    pub fn HalGdmaOpInit(Data: *mut ::ctypes::c_void);
    pub fn HalGdmaOn(pHalGdmaAdapter: PHAL_GDMA_ADAPTER);
    pub fn HalGdmaOff(pHalGdmaAdapter: PHAL_GDMA_ADAPTER);
    pub fn HalGdmaChInit(pHalGdmaAdapter: PHAL_GDMA_ADAPTER) -> BOOL;
    pub fn HalGdmaChDis(pHalGdmaAdapter: PHAL_GDMA_ADAPTER);
    pub fn HalGdmaChEn(pHalGdmaAdapter: PHAL_GDMA_ADAPTER);
    pub fn HalGdmaChSeting(pHalGdmaAdapter: PHAL_GDMA_ADAPTER) -> BOOL;
    pub fn HalGdmaChBlockSeting(pHalGdmaAdapter: PHAL_GDMA_ADAPTER) -> BOOL;
    pub fn HalGdmaChIsrEn(pHalGdmaAdapter: PHAL_GDMA_ADAPTER);
    pub fn HalGdmaChIsrDis(pHalGdmaAdapter: PHAL_GDMA_ADAPTER);
    pub fn HalGdmaChIsrClean(pHalGdmaAdapter: PHAL_GDMA_ADAPTER) -> uint8_t;
    pub fn HalGdmaChCleanAutoSrc(pHalGdmaAdapter: PHAL_GDMA_ADAPTER);
    pub fn HalGdmaChCleanAutoDst(pHalGdmaAdapter: PHAL_GDMA_ADAPTER);
    pub fn HalGdmaChnlRegister(GdmaIdx: uint8_t, ChnlNum: uint8_t)
     -> HAL_Status;
    pub fn HalGdmaChnlUnRegister(GdmaIdx: uint8_t, ChnlNum: uint8_t);
    pub fn HalGdmaChnlAlloc(pChnlOption: *mut HAL_GDMA_CHNL)
     -> PHAL_GDMA_CHNL;
    pub fn HalGdmaChnlFree(pChnl: *mut HAL_GDMA_CHNL);
    pub fn HalGdmaMemCpyInit(pHalGdmaObj: PHAL_GDMA_OBJ) -> BOOL;
    pub fn HalGdmaMemCpyDeInit(pHalGdmaObj: PHAL_GDMA_OBJ);
    pub fn HalGdmaMemCpy(pHalGdmaObj: PHAL_GDMA_OBJ,
                         pDest: *mut ::ctypes::c_void,
                         pSrc: *mut ::ctypes::c_void, len: uint32_t)
     -> *mut ::ctypes::c_void;
    pub fn HalGdmaMemAggr(pHalGdmaObj: PHAL_GDMA_OBJ,
                          pHalGdmaBlock: PHAL_GDMA_BLOCK);
    pub fn HalGdmaMemCpyAggrInit(pHalGdmaObj: PHAL_GDMA_OBJ) -> BOOL;
    pub fn HAL_GPIO_GetPinName(chip_pin: uint32_t) -> uint32_t;
    pub fn HAL_GPIO_PullCtrl(pin: uint32_t, mode: uint32_t);
    pub fn HAL_GPIO_Init(GPIO_Pin: *mut HAL_GPIO_PIN);
    pub fn HAL_GPIO_Irq_Init(GPIO_Pin: *mut HAL_GPIO_PIN);
    pub fn HAL_GPIO_IP_DeInit();
    pub fn HAL_GPIO_IrqHandler_8195a(pData: *mut ::ctypes::c_void)
     -> uint32_t;
    pub fn HAL_GPIO_MbedIrqHandler_8195a(pData: *mut ::ctypes::c_void)
     -> uint32_t;
    pub fn HAL_GPIO_IntCtrl_8195a(GPIO_Pin: *mut HAL_GPIO_PIN, En: uint32_t)
     -> HAL_Status;
    pub fn HAL_GPIO_Init_8195a(GPIO_Pin: *mut HAL_GPIO_PIN) -> HAL_Status;
    pub fn HAL_GPIO_DeInit_8195a(GPIO_Pin: *mut HAL_GPIO_PIN) -> HAL_Status;
    pub fn HAL_GPIO_ReadPin_8195a(GPIO_Pin: *mut HAL_GPIO_PIN)
     -> HAL_GPIO_PIN_STATE;
    pub fn HAL_GPIO_WritePin_8195a(GPIO_Pin: *mut HAL_GPIO_PIN,
                                   Pin_State: HAL_GPIO_PIN_STATE)
     -> HAL_Status;
    pub fn HAL_GPIO_RegIrq_8195a(pIrqHandle: PIRQ_HANDLE) -> HAL_Status;
    pub fn HAL_GPIO_UnRegIrq_8195a(pIrqHandle: PIRQ_HANDLE) -> HAL_Status;
    pub fn HAL_GPIO_UserRegIrq_8195a(GPIO_Pin: *mut HAL_GPIO_PIN,
                                     IrqHandler: *mut ::ctypes::c_void,
                                     IrqData: *mut ::ctypes::c_void)
     -> HAL_Status;
    pub fn HAL_GPIO_UserUnRegIrq_8195a(GPIO_Pin: *mut HAL_GPIO_PIN)
     -> HAL_Status;
    pub fn HAL_GPIO_MaskIrq_8195a(GPIO_Pin: *mut HAL_GPIO_PIN) -> HAL_Status;
    pub fn HAL_GPIO_UnMaskIrq_8195a(GPIO_Pin: *mut HAL_GPIO_PIN)
     -> HAL_Status;
    pub fn HAL_GPIO_IntDebounce_8195a(GPIO_Pin: *mut HAL_GPIO_PIN,
                                      Enable: uint8_t) -> HAL_Status;
    pub fn HAL_GPIO_GetIPPinName_8195a(chip_pin: uint32_t) -> uint32_t;
    pub fn HAL_GPIO_PullCtrl_8195a(chip_pin: uint32_t, pull_type: uint8_t)
     -> HAL_Status;
    pub fn GPIO_GetChipPinName_8195a(port: uint32_t, pin: uint32_t)
     -> uint32_t;
    pub fn GPIO_PullCtrl_8195a(chip_pin: uint32_t, pull_type: uint8_t);
    pub fn GPIO_Int_SetType_8195a(pin_num: uint8_t, int_mode: uint8_t);
    pub fn HAL_GPIO_IntCtrl_8195aV02(GPIO_Pin: *mut HAL_GPIO_PIN,
                                     En: uint32_t) -> HAL_Status;
    pub fn GPIO_Int_Clear_8195aV02(irq_clr: uint32_t) -> uint32_t;
    pub fn HAL_GPIO_ClearISR_8195a(GPIO_Pin: *mut HAL_GPIO_PIN) -> HAL_Status;
    pub fn HalSsiPinmuxEnableRtl8195a(Adaptor: *mut ::ctypes::c_void)
     -> HAL_Status;
    pub fn HalSsiEnableRtl8195a(Adaptor: *mut ::ctypes::c_void) -> HAL_Status;
    pub fn HalSsiDisableRtl8195a(Adaptor: *mut ::ctypes::c_void)
     -> HAL_Status;
    pub fn HalSsiInitRtl8195a(Adaptor: *mut ::ctypes::c_void) -> HAL_Status;
    pub fn HalSsiSetSclkPolarityRtl8195a(Adaptor: *mut ::ctypes::c_void)
     -> HAL_Status;
    pub fn HalSsiSetSclkPhaseRtl8195a(Adaptor: *mut ::ctypes::c_void)
     -> HAL_Status;
    pub fn HalSsiWriteRtl8195a(Adaptor: *mut ::ctypes::c_void,
                               value: uint32_t) -> HAL_Status;
    pub fn HalSsiLoadSettingRtl8195a(Adaptor: *mut ::ctypes::c_void,
                                     Setting: *mut ::ctypes::c_void)
     -> HAL_Status;
    pub fn HalSsiSetInterruptMaskRtl8195a(Adaptor: *mut ::ctypes::c_void)
     -> HAL_Status;
    pub fn HalSsiSetDeviceRoleRtl8195a(Adaptor: *mut ::ctypes::c_void,
                                       Role: uint32_t) -> HAL_Status;
    pub fn HalSsiInterruptEnableRtl8195a(Adaptor: *mut ::ctypes::c_void)
     -> HAL_Status;
    pub fn HalSsiInterruptDisableRtl8195a(Adaptor: *mut ::ctypes::c_void)
     -> HAL_Status;
    pub fn HalSsiReadInterruptRtl8195a(Adaptor: *mut ::ctypes::c_void,
                                       RxData: *mut ::ctypes::c_void,
                                       Length: uint32_t) -> HAL_Status;
    pub fn HalSsiSetRxFifoThresholdLevelRtl8195a(Adaptor:
                                                     *mut ::ctypes::c_void)
     -> HAL_Status;
    pub fn HalSsiSetTxFifoThresholdLevelRtl8195a(Adaptor:
                                                     *mut ::ctypes::c_void)
     -> HAL_Status;
    pub fn HalSsiWriteInterruptRtl8195a(Adaptor: *mut ::ctypes::c_void,
                                        TxData: *mut ::ctypes::c_void,
                                        Length: uint32_t) -> HAL_Status;
    pub fn HalSsiSetSlaveEnableRegisterRtl8195a(Adaptor:
                                                    *mut ::ctypes::c_void,
                                                SlaveIndex: uint32_t)
     -> HAL_Status;
    pub fn HalSsiBusyRtl8195a(Adaptor: *mut ::ctypes::c_void) -> uint32_t;
    pub fn HalSsiWriteableRtl8195a(Adaptor: *mut ::ctypes::c_void)
     -> uint32_t;
    pub fn HalSsiReadableRtl8195a(Adaptor: *mut ::ctypes::c_void) -> uint32_t;
    pub fn HalSsiGetInterruptMaskRtl8195a(Adaptor: *mut ::ctypes::c_void)
     -> uint32_t;
    pub fn HalSsiGetRxFifoLevelRtl8195a(Adaptor: *mut ::ctypes::c_void)
     -> uint32_t;
    pub fn HalSsiGetTxFifoLevelRtl8195a(Adaptor: *mut ::ctypes::c_void)
     -> uint32_t;
    pub fn HalSsiGetStatusRtl8195a(Adaptor: *mut ::ctypes::c_void)
     -> uint32_t;
    pub fn HalSsiGetInterruptStatusRtl8195a(Adaptor: *mut ::ctypes::c_void)
     -> uint32_t;
    pub fn HalSsiReadRtl8195a(Adaptor: *mut ::ctypes::c_void) -> uint32_t;
    pub fn HalSsiGetRawInterruptStatusRtl8195a(Adaptor: *mut ::ctypes::c_void)
     -> uint32_t;
    pub fn HalSsiGetSlaveEnableRegisterRtl8195a(Adaptor:
                                                    *mut ::ctypes::c_void)
     -> uint32_t;
    pub fn _SsiReadInterrupt(Adaptor: *mut ::ctypes::c_void);
    pub fn _SsiWriteInterrupt(Adaptor: *mut ::ctypes::c_void);
    pub fn _SsiIrqHandle(Adaptor: *mut ::ctypes::c_void) -> uint32_t;
    pub fn _SsiReadInterruptRtl8195a(Adapter: *mut ::ctypes::c_void);
    pub fn _SsiWriteInterruptRtl8195a(Adapter: *mut ::ctypes::c_void);
    pub fn HalSsiInitRtl8195a_Patch(Adaptor: *mut ::ctypes::c_void)
     -> HAL_Status;
    pub fn HalSsiPinmuxEnableRtl8195a_Patch(Adaptor: *mut ::ctypes::c_void)
     -> HAL_Status;
    pub fn HalSsiPinmuxDisableRtl8195a(Adaptor: *mut ::ctypes::c_void)
     -> HAL_Status;
    pub fn HalSsiDeInitRtl8195a(Adapter: *mut ::ctypes::c_void) -> HAL_Status;
    pub fn HalSsiClockOffRtl8195a(Adapter: *mut ::ctypes::c_void)
     -> HAL_Status;
    pub fn HalSsiClockOnRtl8195a(Adapter: *mut ::ctypes::c_void)
     -> HAL_Status;
    pub fn HalSsiSetSclkRtl8195a(Adapter: *mut ::ctypes::c_void,
                                 ClkRate: uint32_t);
    pub fn HalSsiIntReadRtl8195a(Adapter: *mut ::ctypes::c_void,
                                 RxData: *mut ::ctypes::c_void,
                                 Length: uint32_t) -> HAL_Status;
    pub fn HalSsiIntWriteRtl8195a(Adapter: *mut ::ctypes::c_void,
                                  pTxData: *mut uint8_t, Length: uint32_t)
     -> HAL_Status;
    pub fn HalSsiTxFIFOThresholdRtl8195a(Adaptor: *mut ::ctypes::c_void,
                                         txftl: uint32_t);
    pub fn HalSsiEnterCriticalRtl8195a(Data: *mut ::ctypes::c_void)
     -> HAL_Status;
    pub fn HalSsiExitCriticalRtl8195a(Data: *mut ::ctypes::c_void)
     -> HAL_Status;
    pub fn HalSsiIsTimeoutRtl8195a(StartCount: uint32_t, TimeoutCnt: uint32_t)
     -> HAL_Status;
    pub fn HalSsiStopRecvRtl8195a(Data: *mut ::ctypes::c_void) -> HAL_Status;
    pub fn HalSsiTxGdmaLoadDefRtl8195a(Adapter: *mut ::ctypes::c_void);
    pub fn HalSsiRxGdmaLoadDefRtl8195a(Adapter: *mut ::ctypes::c_void);
    pub fn HalSsiDmaInitRtl8195a(Adapter: *mut ::ctypes::c_void);
    pub fn HalSsiDmaSendRtl8195a(Adapter: *mut ::ctypes::c_void,
                                 pTxData: *mut uint8_t, Length: uint32_t)
     -> HAL_Status;
    pub fn HalSsiDmaRecvRtl8195a(Adapter: *mut ::ctypes::c_void,
                                 pRxData: *mut uint8_t, Length: uint32_t)
     -> HAL_Status;
    pub fn HalSsiDmaSendMultiBlockRtl8195a(Adapter: *mut ::ctypes::c_void,
                                           pRxData: *mut uint8_t,
                                           Length: uint32_t) -> HAL_Status;
    pub fn HalSsiDmaRecvMultiBlockRtl8195a(Adapter: *mut ::ctypes::c_void,
                                           pRxData: *mut uint8_t,
                                           Length: uint32_t) -> HAL_Status;
    pub fn HalSsiOpInit(Adaptor: *mut ::ctypes::c_void);
    pub fn HalSsiInit(Data: *mut ::ctypes::c_void) -> HAL_Status;
    pub fn HalSsiDeInit(Data: *mut ::ctypes::c_void) -> HAL_Status;
    pub fn HalSsiEnable(Data: *mut ::ctypes::c_void) -> HAL_Status;
    pub fn HalSsiDisable(Data: *mut ::ctypes::c_void) -> HAL_Status;
    pub fn HalSsiEnterCritical(Data: *mut ::ctypes::c_void) -> HAL_Status;
    pub fn HalSsiExitCritical(Data: *mut ::ctypes::c_void) -> HAL_Status;
    pub fn HalSsiTimeout(StartCount: uint32_t, TimeoutCnt: uint32_t)
     -> HAL_Status;
    pub fn HalSsiStopRecv(Data: *mut ::ctypes::c_void) -> HAL_Status;
    pub fn HalSsiSetFormat(Data: *mut ::ctypes::c_void) -> HAL_Status;
    pub fn HalSsiTxGdmaInit(pHalSsiOp: PHAL_SSI_OP,
                            pHalSsiAdapter: PHAL_SSI_ADAPTOR) -> HAL_Status;
    pub fn HalSsiTxGdmaDeInit(pHalSsiAdapter: PHAL_SSI_ADAPTOR);
    pub fn HalSsiRxGdmaInit(pHalSsiOp: PHAL_SSI_OP,
                            pHalSsiAdapter: PHAL_SSI_ADAPTOR) -> HAL_Status;
    pub fn HalSsiRxGdmaDeInit(pHalSsiAdapter: PHAL_SSI_ADAPTOR);
    pub fn HalSsiRxMultiBlkChnl(pHalSsiAdapter: PHAL_SSI_ADAPTOR)
     -> HAL_Status;
    pub fn HalSsiDmaRecv(Adapter: *mut ::ctypes::c_void,
                         pRxData: *mut uint8_t, Length: uint32_t)
     -> HAL_Status;
    pub fn HalSsiDmaSend(Adapter: *mut ::ctypes::c_void,
                         pTxData: *mut uint8_t, Length: uint32_t)
     -> HAL_Status;
    pub fn HalRuartGetDebugValueRtl8195a(Data: *mut ::ctypes::c_void,
                                         DbgSel: uint32_t) -> uint32_t;
    pub fn RuartResetRxFifoRtl8195a(UartIndex: uint8_t);
    pub fn HalRuartResetRxFifoRtl8195a(Data: *mut ::ctypes::c_void)
     -> HAL_Status;
    pub fn HalRuartInitRtl8195a(Data: *mut ::ctypes::c_void) -> HAL_Status;
    pub fn HalRuartDeInitRtl8195a(Data: *mut ::ctypes::c_void);
    pub fn HalRuartPutCRtl8195a(Data: *mut ::ctypes::c_void, TxData: uint8_t)
     -> HAL_Status;
    pub fn HalRuartSendRtl8195a(Data: *mut ::ctypes::c_void,
                                pTxData: *mut uint8_t, Length: uint32_t,
                                Timeout: uint32_t) -> uint32_t;
    pub fn HalRuartIntSendRtl8195a(Data: *mut ::ctypes::c_void,
                                   pTxData: *mut uint8_t, Length: uint32_t)
     -> HAL_Status;
    pub fn HalRuartDmaSendRtl8195a(Data: *mut ::ctypes::c_void,
                                   pTxData: *mut uint8_t, Length: uint32_t)
     -> HAL_Status;
    pub fn HalRuartStopSendRtl8195a(Data: *mut ::ctypes::c_void)
     -> HAL_Status;
    pub fn HalRuartGetCRtl8195a(Data: *mut ::ctypes::c_void,
                                pRxByte: *mut uint8_t) -> HAL_Status;
    pub fn HalRuartRecvRtl8195a(Data: *mut ::ctypes::c_void,
                                pRxData: *mut uint8_t, Length: uint32_t,
                                Timeout: uint32_t) -> uint32_t;
    pub fn HalRuartIntRecvRtl8195a(Data: *mut ::ctypes::c_void,
                                   pRxData: *mut uint8_t, Length: uint32_t)
     -> HAL_Status;
    pub fn HalRuartDmaRecvRtl8195a(Data: *mut ::ctypes::c_void,
                                   pRxData: *mut uint8_t, Length: uint32_t)
     -> HAL_Status;
    pub fn HalRuartStopRecvRtl8195a(Data: *mut ::ctypes::c_void)
     -> HAL_Status;
    pub fn HalRuartGetIMRRtl8195a(Data: *mut ::ctypes::c_void) -> uint8_t;
    pub fn HalRuartSetIMRRtl8195a(Data: *mut ::ctypes::c_void);
    pub fn HalRuartDmaInitRtl8195a(Data: *mut ::ctypes::c_void);
    pub fn HalRuartRTSCtrlRtl8195a(Data: *mut ::ctypes::c_void,
                                   RtsCtrl: BOOLEAN);
    pub fn HalRuartRegIrqRtl8195a(Data: *mut ::ctypes::c_void);
    pub fn HalRuartIntEnableRtl8195a(Data: *mut ::ctypes::c_void);
    pub fn HalRuartIntDisableRtl8195a(Data: *mut ::ctypes::c_void);
    pub fn HalRuartAdapterLoadDefRtl8195a(pAdp: *mut ::ctypes::c_void,
                                          UartIdx: uint8_t);
    pub fn HalRuartTxGdmaLoadDefRtl8195a(pAdp: *mut ::ctypes::c_void,
                                         pCfg: *mut ::ctypes::c_void);
    pub fn HalRuartRxGdmaLoadDefRtl8195a(pAdp: *mut ::ctypes::c_void,
                                         pCfg: *mut ::ctypes::c_void);
    pub fn HalRuartIntSendRtl8195aV02(Data: *mut ::ctypes::c_void,
                                      pTxData: *mut uint8_t, Length: uint32_t)
     -> HAL_Status;
    pub fn HalRuartIntRecvRtl8195aV02(Data: *mut ::ctypes::c_void,
                                      pRxData: *mut uint8_t, Length: uint32_t)
     -> HAL_Status;
    pub fn FindElementIndex_v02(Element: uint32_t, Array: *mut uint32_t,
                                ElementNo: uint32_t) -> int32_t;
    pub fn HalRuartInitRtl8195a_v02(Data: *mut ::ctypes::c_void)
     -> HAL_Status;
    pub fn HalRuartResetTxFifoRtl8195a(Data: *mut ::ctypes::c_void)
     -> HAL_Status;
    pub fn HalRuartResetRxFifoRtl8195a_Patch(Data: *mut ::ctypes::c_void)
     -> HAL_Status;
    pub fn HalRuartResetTRxFifoRtl8195a(Data: *mut ::ctypes::c_void)
     -> HAL_Status;
    pub fn HalRuartSetBaudRateRtl8195a(Data: *mut ::ctypes::c_void)
     -> HAL_Status;
    pub fn HalRuartEnableRtl8195a(Data: *mut ::ctypes::c_void) -> HAL_Status;
    pub fn HalRuartDisableRtl8195a(Data: *mut ::ctypes::c_void) -> HAL_Status;
    pub fn HalRuartFlowCtrlRtl8195a(Data: *mut ::ctypes::c_void)
     -> HAL_Status;
    pub fn _UartTxDmaIrqHandle_Patch(Data: *mut ::ctypes::c_void) -> uint32_t;
    pub fn _UartRxDmaIrqHandle_Patch(Data: *mut ::ctypes::c_void) -> uint32_t;
    pub fn HalRuartDmaSendRtl8195a_Patch(Data: *mut ::ctypes::c_void,
                                         pTxData: *mut uint8_t,
                                         Length: uint32_t) -> HAL_Status;
    pub fn HalRuartDmaRecvRtl8195a_Patch(Data: *mut ::ctypes::c_void,
                                         pRxData: *mut uint8_t,
                                         Length: uint32_t) -> HAL_Status;
    pub fn HalRuartMultiBlkDmaSendRtl8195a(Data: *mut ::ctypes::c_void,
                                           pTxData: *mut uint8_t,
                                           Length: uint32_t) -> HAL_Status;
    pub fn HalRuartMultiBlkDmaRecvRtl8195a(Data: *mut ::ctypes::c_void,
                                           pRxData: *mut uint8_t,
                                           Length: uint32_t) -> HAL_Status;
    pub fn RuartIsTimeout(StartCount: uint32_t, TimeoutCnt: uint32_t)
     -> HAL_Status;
    pub fn HalRuartStopRecvRtl8195a_Patch(Data: *mut ::ctypes::c_void)
     -> HAL_Status;
    pub fn HalRuartStopSendRtl8195a_Patch(Data: *mut ::ctypes::c_void)
     -> HAL_Status;
    pub fn HalRuartEnterCriticalRtl8195a(Data: *mut ::ctypes::c_void);
    pub fn HalRuartExitCriticalRtl8195a(Data: *mut ::ctypes::c_void);
    pub fn HalRuartOpInit(Data: *mut ::ctypes::c_void);
    pub fn HalRuartTxGdmaInit(pHalRuartAdapter: PHAL_RUART_ADAPTER,
                              pUartGdmaConfig: PUART_DMA_CONFIG,
                              IsMultiBlk: uint8_t) -> HAL_Status;
    pub fn HalRuartTxGdmaDeInit(pUartGdmaConfig: PUART_DMA_CONFIG);
    pub fn HalRuartRxGdmaInit(pHalRuartAdapter: PHAL_RUART_ADAPTER,
                              pUartGdmaConfig: PUART_DMA_CONFIG,
                              IsMultiBlk: uint8_t) -> HAL_Status;
    pub fn HalRuartRxGdmaDeInit(pUartGdmaConfig: PUART_DMA_CONFIG);
    pub fn HalRuartResetTxFifo(Data: *mut ::ctypes::c_void) -> HAL_Status;
    pub fn HalRuartResetRxFifo(Data: *mut ::ctypes::c_void) -> HAL_Status;
    pub fn HalRuartSetBaudRate(Data: *mut ::ctypes::c_void) -> HAL_Status;
    pub fn HalRuartInit(Data: *mut ::ctypes::c_void) -> HAL_Status;
    pub fn HalRuartDeInit(Data: *mut ::ctypes::c_void);
    pub fn HalRuartDisable(Data: *mut ::ctypes::c_void) -> HAL_Status;
    pub fn HalRuartEnable(Data: *mut ::ctypes::c_void) -> HAL_Status;
    pub fn HalRuartFlowCtrl(Data: *mut ::ctypes::c_void) -> HAL_Status;
    pub fn HalRuartEnterCritical(Data: *mut ::ctypes::c_void);
    pub fn HalRuartExitCritical(Data: *mut ::ctypes::c_void);
    pub fn HalRuartDmaSend(Data: *mut ::ctypes::c_void, pTxBuf: *mut uint8_t,
                           Length: uint32_t) -> HAL_Status;
    pub fn HalRuartDmaRecv(Data: *mut ::ctypes::c_void, pRxBuf: *mut uint8_t,
                           Length: uint32_t) -> HAL_Status;
    pub fn RuartLock(pHalRuartAdapter: PHAL_RUART_ADAPTER) -> HAL_Status;
    pub fn RuartUnLock(pHalRuartAdapter: PHAL_RUART_ADAPTER);
    pub fn HalI2CWrite32(I2CIdx: uint8_t, I2CReg: uint8_t, I2CVal: uint32_t);
    pub fn HalI2CRead32(I2CIdx: uint8_t, I2CReg: uint8_t) -> uint32_t;
    pub fn HalI2CEnableRtl8195a(Data: *mut ::ctypes::c_void) -> HAL_Status;
    pub fn HalI2CInit8195a(Data: *mut ::ctypes::c_void) -> HAL_Status;
    pub fn HalI2CDeInit8195a(Data: *mut ::ctypes::c_void) -> HAL_Status;
    pub fn HalI2CSetCLKRtl8195a(Data: *mut ::ctypes::c_void) -> HAL_Status;
    pub fn HalI2CMassSendRtl8195a(Data: *mut ::ctypes::c_void) -> HAL_Status;
    pub fn HalI2CSendRtl8195a(Data: *mut ::ctypes::c_void) -> HAL_Status;
    pub fn HalI2CReceiveRtl8195a(Data: *mut ::ctypes::c_void) -> uint8_t;
    pub fn HalI2CIntrCtrl8195a(Data: *mut ::ctypes::c_void) -> HAL_Status;
    pub fn HalI2CClrIntrRtl8195a(Data: *mut ::ctypes::c_void) -> HAL_Status;
    pub fn HalI2CClrAllIntrRtl8195a(Data: *mut ::ctypes::c_void)
     -> HAL_Status;
    pub fn HalI2CDMACtrl8195a(Data: *mut ::ctypes::c_void) -> HAL_Status;
    pub fn HalI2CReadRegRtl8195a(Data: *mut ::ctypes::c_void, I2CReg: uint8_t)
     -> uint32_t;
    pub fn HalI2CWriteRegRtl8195a(Data: *mut ::ctypes::c_void,
                                  I2CReg: uint8_t, RegVal: uint32_t)
     -> HAL_Status;
    pub fn HalI2CSendRtl8195aV02(Data: *mut ::ctypes::c_void) -> HAL_Status;
    pub fn HalI2CSetCLKRtl8195aV02(Data: *mut ::ctypes::c_void) -> HAL_Status;
    pub fn HalI2CSendRtl8195a_V04(Data: *mut ::ctypes::c_void) -> HAL_Status;
    pub fn HalI2CMassSendRtl8195a_V04(Data: *mut ::ctypes::c_void)
     -> HAL_Status;
    pub fn HalI2CInit8195a_V04(Data: *mut ::ctypes::c_void) -> HAL_Status;
    pub fn HalI2CSetCLKRtl8195a_V04(Data: *mut ::ctypes::c_void)
     -> HAL_Status;
    pub fn HalI2CInit8195a_Patch(Data: *mut ::ctypes::c_void) -> HAL_Status;
    pub fn HalI2CSendRtl8195a_Patch(Data: *mut ::ctypes::c_void)
     -> HAL_Status;
    pub fn HalI2CSetCLKRtl8195a_Patch(Data: *mut ::ctypes::c_void)
     -> HAL_Status;
    pub fn HalI2CMassSendRtl8195a_Patch(Data: *mut ::ctypes::c_void)
     -> HAL_Status;
    pub fn HalI2CEnableRtl8195a_Patch(Data: *mut ::ctypes::c_void)
     -> HAL_Status;
    pub fn RtkI2CLoadDefault(Data: *mut ::ctypes::c_void) -> HAL_Status;
    pub fn RtkI2CInit(Data: *mut ::ctypes::c_void) -> HAL_Status;
    pub fn RtkI2CDeInit(Data: *mut ::ctypes::c_void) -> HAL_Status;
    pub fn RtkI2CSend(Data: *mut ::ctypes::c_void) -> HAL_Status;
    pub fn RtkI2CReceive(Data: *mut ::ctypes::c_void) -> HAL_Status;
    pub fn RtkSalI2COpInit(Data: *mut ::ctypes::c_void);
    pub fn RtkI2CSendUserAddr(Data: *mut ::ctypes::c_void, MtrWr: uint8_t)
     -> HAL_Status;
    pub fn RtkI2CIoCtrl(Data: *mut ::ctypes::c_void) -> HAL_Status;
    pub fn RtkI2CPowerCtrl(Data: *mut ::ctypes::c_void) -> HAL_Status;
    pub fn RtkI2CInitForPS(Data: *mut ::ctypes::c_void) -> HAL_Status;
    pub fn RtkI2CDeInitForPS(Data: *mut ::ctypes::c_void) -> HAL_Status;
    pub fn RtkI2CDisablePS(Data: *mut ::ctypes::c_void) -> HAL_Status;
    pub fn RtkI2CEnablePS(Data: *mut ::ctypes::c_void) -> HAL_Status;
    pub fn RtkI2CGetMngtAdpt(I2CIdx: uint8_t) -> PSAL_I2C_MNGT_ADPT;
    pub fn RtkI2CFreeMngtAdpt(pSalI2CMngtAdpt: PSAL_I2C_MNGT_ADPT)
     -> HAL_Status;
    pub fn RtkI2CGetSalHnd(I2CIdx: uint8_t) -> PSAL_I2C_HND;
    pub fn RtkI2CFreeSalHnd(pSalI2CHND: PSAL_I2C_HND) -> HAL_Status;
    pub fn RtkSalI2CSts(Data: *mut ::ctypes::c_void) -> uint32_t;
    pub fn I2CISRHandle(Data: *mut ::ctypes::c_void);
    pub fn I2CTXGDMAISRHandle(Data: *mut ::ctypes::c_void);
    pub fn I2CRXGDMAISRHandle(Data: *mut ::ctypes::c_void);
    pub fn I2CIsTimeout(StartCount: uint32_t, TimeoutCnt: uint32_t)
     -> HAL_Status;
    pub fn HalI2COpInit(Data: *mut ::ctypes::c_void);
    pub fn HalI2COpInitV02(Data: *mut ::ctypes::c_void);
    pub fn I2CISRHandleV02(Data: *mut ::ctypes::c_void);
    pub fn RtkI2CSendV02(Data: *mut ::ctypes::c_void) -> HAL_Status;
    pub fn RtkI2CReceiveV02(Data: *mut ::ctypes::c_void) -> HAL_Status;
    pub fn RtkSalI2COpInitV02(Data: *mut ::ctypes::c_void);
    pub fn HalI2COpInit_V04(Data: *mut ::ctypes::c_void);
    pub fn I2CISRHandle_V04(Data: *mut ::ctypes::c_void);
    pub fn RtkI2CSend_Patch(Data: *mut ::ctypes::c_void) -> HAL_Status;
    pub fn RtkI2CReceive_Patch(Data: *mut ::ctypes::c_void) -> HAL_Status;
    pub fn HalI2COpInit_Patch(Data: *mut ::ctypes::c_void);
    pub fn I2CISRHandle_Patch(Data: *mut ::ctypes::c_void);
    pub fn HAL_Pwm_Init(pPwmAdapt: *mut HAL_PWM_ADAPTER, pwm_id: uint32_t,
                        sel: uint32_t) -> HAL_Status;
    pub fn HAL_Pwm_Enable(pPwmAdapt: *mut HAL_PWM_ADAPTER);
    pub fn HAL_Pwm_Disable(pPwmAdapt: *mut HAL_PWM_ADAPTER);
    pub fn HAL_Pwm_SetDuty(pPwmAdapt: *mut HAL_PWM_ADAPTER, period: uint32_t,
                           pulse_width: uint32_t);
    pub fn HAL_Pwm_SetDuty_8195a(pPwmAdapt: *mut HAL_PWM_ADAPTER,
                                 period: uint32_t, pulse_width: uint32_t);
    pub fn HAL_Pwm_Init_8195a(pPwmAdapt: *mut HAL_PWM_ADAPTER) -> HAL_Status;
    pub fn HAL_Pwm_Enable_8195a(pPwmAdapt: *mut HAL_PWM_ADAPTER);
    pub fn HAL_Pwm_Disable_8195a(pPwmAdapt: *mut HAL_PWM_ADAPTER);
    pub fn HalI2SWrite32(I2SIdx: uint8_t, I2SReg: uint8_t, I2SVal: uint32_t);
    pub fn HalI2SRead32(I2SIdx: uint8_t, I2SReg: uint8_t) -> uint32_t;
    pub fn HalI2SInitRtl8195a(Data: *mut ::ctypes::c_void) -> RTK_STATUS;
    pub fn HalI2SInitRtl8195a_Patch(Data: *mut ::ctypes::c_void)
     -> RTK_STATUS;
    pub fn HalI2SDeInitRtl8195a(Data: *mut ::ctypes::c_void) -> RTK_STATUS;
    pub fn HalI2STxRtl8195a(Data: *mut ::ctypes::c_void, pBuff: *mut uint8_t)
     -> RTK_STATUS;
    pub fn HalI2SRxRtl8195a(Data: *mut ::ctypes::c_void, pBuff: *mut uint8_t)
     -> RTK_STATUS;
    pub fn HalI2SEnableRtl8195a(Data: *mut ::ctypes::c_void) -> RTK_STATUS;
    pub fn HalI2SIntrCtrlRtl8195a(Data: *mut ::ctypes::c_void) -> RTK_STATUS;
    pub fn HalI2SReadRegRtl8195a(Data: *mut ::ctypes::c_void, I2SReg: uint8_t)
     -> uint32_t;
    pub fn HalI2SSetRateRtl8195a(Data: *mut ::ctypes::c_void) -> RTK_STATUS;
    pub fn HalI2SSetWordLenRtl8195a(Data: *mut ::ctypes::c_void)
     -> RTK_STATUS;
    pub fn HalI2SSetChNumRtl8195a(Data: *mut ::ctypes::c_void) -> RTK_STATUS;
    pub fn HalI2SSetPageNumRtl8195a(Data: *mut ::ctypes::c_void)
     -> RTK_STATUS;
    pub fn HalI2SSetPageSizeRtl8195a(Data: *mut ::ctypes::c_void)
     -> RTK_STATUS;
    pub fn HalI2SSetDirectionRtl8195a(Data: *mut ::ctypes::c_void)
     -> RTK_STATUS;
    pub fn HalI2SSetDMABufRtl8195a(Data: *mut ::ctypes::c_void) -> RTK_STATUS;
    pub fn HalI2SClrIntrRtl8195a(Data: *mut ::ctypes::c_void) -> RTK_STATUS;
    pub fn HalI2SClrAllIntrRtl8195a(Data: *mut ::ctypes::c_void)
     -> RTK_STATUS;
    pub fn HalI2SDMACtrlRtl8195a(Data: *mut ::ctypes::c_void) -> RTK_STATUS;
    pub fn HalI2SGetTxPageRtl8195a(Data: *mut ::ctypes::c_void) -> uint8_t;
    pub fn HalI2SGetRxPageRtl8195a(Data: *mut ::ctypes::c_void) -> uint8_t;
    pub fn HalI2SPageSendRtl8195a(Data: *mut ::ctypes::c_void,
                                  PageIdx: uint8_t) -> RTK_STATUS;
    pub fn HalI2SPageRecvRtl8195a(Data: *mut ::ctypes::c_void) -> RTK_STATUS;
    pub fn HalI2SClearAllOwnBitRtl8195a(Data: *mut ::ctypes::c_void)
     -> RTK_STATUS;
    pub fn RtkI2SLoadDefault(Adapter: *mut ::ctypes::c_void,
                             Setting: *mut ::ctypes::c_void) -> HAL_Status;
    pub fn RtkI2SInit(Data: *mut ::ctypes::c_void) -> HAL_Status;
    pub fn RtkI2SDeInit(Data: *mut ::ctypes::c_void) -> HAL_Status;
    pub fn RtkI2SEnable(Data: *mut ::ctypes::c_void) -> HAL_Status;
    pub fn RtkI2SDisable(Data: *mut ::ctypes::c_void) -> HAL_Status;
    pub fn HalI2SInit(Data: *mut ::ctypes::c_void) -> HAL_Status;
    pub fn HalI2SDeInit(Data: *mut ::ctypes::c_void);
    pub fn HalI2SDisable(Data: *mut ::ctypes::c_void) -> HAL_Status;
    pub fn HalI2SEnable(Data: *mut ::ctypes::c_void) -> HAL_Status;
    pub fn I2S0ISRHandle(Data: *mut ::ctypes::c_void);
    pub fn I2S1ISRHandle(Data: *mut ::ctypes::c_void);
    pub fn HalI2SOpInit(Data: *mut ::ctypes::c_void);
    pub fn HalDACInit8195a(Data: *mut ::ctypes::c_void) -> RTK_STATUS;
    pub fn HalDACDeInit8195a(Data: *mut ::ctypes::c_void) -> RTK_STATUS;
    pub fn HalDACEnableRtl8195a(Data: *mut ::ctypes::c_void) -> RTK_STATUS;
    pub fn HalDACIntrCtrl8195a(Data: *mut ::ctypes::c_void) -> RTK_STATUS;
    pub fn HalDACSendRtl8195a(Data: *mut ::ctypes::c_void) -> uint8_t;
    pub fn HalDACReadRegRtl8195a(Data: *mut ::ctypes::c_void, I2CReg: uint8_t)
     -> uint32_t;
    pub fn HalDACOpInit(Data: *mut ::ctypes::c_void);
    pub fn RtkDACLoadDefault(Data: *mut ::ctypes::c_void) -> RTK_STATUS;
    pub fn RtkDACInit(Data: *mut ::ctypes::c_void) -> RTK_STATUS;
    pub fn RtkDACDeInit(Data: *mut ::ctypes::c_void) -> RTK_STATUS;
    pub fn RtkDACSend(Data: *mut ::ctypes::c_void) -> RTK_STATUS;
    pub fn RtkDACGetSalHnd(DACIdx: uint8_t) -> PSAL_DAC_HND;
    pub fn RtkDACFreeSalHnd(pSalDACHND: PSAL_DAC_HND) -> RTK_STATUS;
    pub fn RtkDACGetMngtAdpt(DACIdx: uint8_t) -> PSAL_DAC_MNGT_ADPT;
    pub fn RtkDACFreeMngtAdpt(pSalDACMngtAdpt: PSAL_DAC_MNGT_ADPT)
     -> RTK_STATUS;
    pub fn HalADCInit8195a(Data: *mut ::ctypes::c_void) -> RTK_STATUS;
    pub fn HalADCDeInit8195a(Data: *mut ::ctypes::c_void) -> RTK_STATUS;
    pub fn HalADCEnableRtl8195a(Data: *mut ::ctypes::c_void) -> RTK_STATUS;
    pub fn HalADCIntrCtrl8195a(Data: *mut ::ctypes::c_void) -> RTK_STATUS;
    pub fn HalADCReceiveRtl8195a(Data: *mut ::ctypes::c_void) -> uint32_t;
    pub fn HalADCReadRegRtl8195a(Data: *mut ::ctypes::c_void, I2CReg: uint8_t)
     -> uint32_t;
    pub fn HalADCOpInit(Data: *mut ::ctypes::c_void);
    pub fn RtkADCGetSalHnd(DACIdx: uint8_t) -> PSAL_ADC_HND;
    pub fn RtkADCFreeSalHnd(pSalADCHND: PSAL_ADC_HND) -> RTK_STATUS;
    pub fn RtkADCLoadDefault(Data: *mut ::ctypes::c_void) -> RTK_STATUS;
    pub fn RtkADCInit(Data: *mut ::ctypes::c_void) -> RTK_STATUS;
    pub fn RtkADCDeInit(Data: *mut ::ctypes::c_void) -> RTK_STATUS;
    pub fn RtkADCReceive(Data: *mut ::ctypes::c_void) -> uint32_t;
    pub fn RtkADCReceiveBuf(Data: *mut ::ctypes::c_void, pBuf: *mut uint32_t)
     -> uint32_t;
    pub fn RtkADCRxManualRotate(Data: *mut ::ctypes::c_void,
                                pBuf: *mut uint32_t) -> uint32_t;
    pub fn RtkADCGetMngtAdpt(ADCIdx: uint8_t) -> PSAL_ADC_MNGT_ADPT;
    pub fn RtkADCFreeMngtAdpt(pSalADCMngtAdpt: PSAL_ADC_MNGT_ADPT)
     -> RTK_STATUS;
    pub fn ADCISRHandle(Data: *mut ::ctypes::c_void);
    pub fn ADCGDMAISRHandle(Data: *mut ::ctypes::c_void);
    pub fn RtkADCDisablePS(Data: *mut ::ctypes::c_void) -> HAL_Status;
    pub fn RtkADCEnablePS(Data: *mut ::ctypes::c_void) -> HAL_Status;
    pub fn A2NWriteCatch(pNFCAdapte: *mut ::ctypes::c_void, N2AWPage: uint8_t,
                         Length: uint8_t, WData: *mut uint32_t);
    pub fn A2NReadCatch(pNFCAdapte: *mut ::ctypes::c_void, A2NRPage: uint8_t);
    pub fn HalNFCDmemInit(pTagData: *mut uint32_t, TagLen: uint32_t);
    pub fn HalNFCInit(pNFCAdp: PNFC_ADAPTER);
    pub fn HalNFCDeinit(pNFCAdp: PNFC_ADAPTER);
    pub fn HalNFCFwDownload();
    pub fn HalNFCDbgRead32(Addr: uint32_t) -> uint32_t;
    pub fn HalNFCDbgWrite32(Addr: uint32_t, Data: uint32_t);
    pub fn HalNFCOpInit(Data: *mut ::ctypes::c_void);
    pub fn WDGInitial(Period: uint32_t);
    pub fn WDGIrqInitial();
    pub fn WDGStop();
    pub fn WDGRefresh();
    pub fn WDGIrqCallBackReg(CallBack: *mut ::ctypes::c_void, Id: uint32_t);
    pub fn HalLogUartIrqHandle(Data: *mut ::ctypes::c_void);
    pub fn HalLogUartSetBaudRate(pUartAdapter: *mut HAL_LOG_UART_ADAPTER);
    pub fn HalLogUartSetLineCtrl(pUartAdapter: *mut HAL_LOG_UART_ADAPTER);
    pub fn HalLogUartSetIntEn(pUartAdapter: *mut HAL_LOG_UART_ADAPTER);
    pub fn HalLogUartInitSetting(pUartAdapter: *mut HAL_LOG_UART_ADAPTER)
     -> uint32_t;
    pub fn HalLogUartRecv(pUartAdapter: *mut HAL_LOG_UART_ADAPTER,
                          pRxData: *mut uint8_t, Length: uint32_t,
                          TimeoutMS: uint32_t) -> uint32_t;
    pub fn HalLogUartSend(pUartAdapter: *mut HAL_LOG_UART_ADAPTER,
                          pTxData: *mut uint8_t, Length: uint32_t,
                          TimeoutMS: uint32_t) -> uint32_t;
    pub fn HalLogUartIntSend(pUartAdapter: *mut HAL_LOG_UART_ADAPTER,
                             pTxData: *mut uint8_t, Length: uint32_t)
     -> HAL_Status;
    pub fn HalLogUartIntRecv(pUartAdapter: *mut HAL_LOG_UART_ADAPTER,
                             pRxData: *mut uint8_t, Length: uint32_t)
     -> HAL_Status;
    pub fn HalLogUartAbortIntSend(pUartAdapter: *mut HAL_LOG_UART_ADAPTER);
    pub fn HalLogUartAbortIntRecv(pUartAdapter: *mut HAL_LOG_UART_ADAPTER);
    pub fn HalLogUartRstFIFO(pUartAdapter: *mut HAL_LOG_UART_ADAPTER,
                             RstCtrl: uint8_t) -> HAL_Status;
    pub fn HalLogUartEnable(pUartAdapter: *mut HAL_LOG_UART_ADAPTER);
    pub fn HalLogUartDisable(pUartAdapter: *mut HAL_LOG_UART_ADAPTER);
    pub fn HalMiiInitIrqRtl8195a(Data: *mut ::ctypes::c_void);
    pub fn HalMiiInitRtl8195a() -> int32_t;
    pub fn HalMiiDeInitRtl8195a();
    pub fn HalMiiWriteDataRtl8195a(Data: *const ::ctypes::c_char,
                                   Size: uint32_t) -> int32_t;
    pub fn HalMiiSendPacketRtl8195a() -> uint32_t;
    pub fn HalMiiReceivePacketRtl8195a() -> uint32_t;
    pub fn HalMiiReadDataRtl8195a(Data: *mut uint8_t, Size: uint32_t)
     -> uint32_t;
    pub fn HalMiiGetMacAddressRtl8195a(Addr: *mut uint8_t);
    pub fn HalMiiGetLinkStatusRtl8195a() -> uint32_t;
    pub fn HalMiiForceLinkRtl8195a(Speed: int32_t, Duplex: int32_t);
    pub fn HalMiiInit() -> int32_t;
    pub fn HalMiiDeInit();
    pub fn HalMiiWriteData(Data: *const ::ctypes::c_char, Size: uint32_t)
     -> int32_t;
    pub fn HalMiiSendPacket() -> uint32_t;
    pub fn HalMiiReceivePacket() -> uint32_t;
    pub fn HalMiiReadData(Data: *mut uint8_t, Size: uint32_t) -> uint32_t;
    pub fn HalMiiGetMacAddress(Addr: *mut uint8_t);
    pub fn HalMiiGetLinkStatus() -> uint32_t;
    pub fn HalMiiForceLink(Speed: int32_t, Duplex: int32_t);
    pub fn NVIC_SetVector(IRQn: IRQn_Type, vector: uint32_t);
    pub fn NVIC_GetVector(IRQn: IRQn_Type) -> uint32_t;
    pub fn serial_init(obj: *mut serial_t, tx: PinName, rx: PinName);
    pub fn serial_free(obj: *mut serial_t);
    pub fn serial_baud(obj: *mut serial_t, baudrate: ::ctypes::c_int);
    pub fn serial_format(obj: *mut serial_t, data_bits: ::ctypes::c_int,
                         parity: SerialParity, stop_bits: ::ctypes::c_int);
    pub fn serial_irq_handler(obj: *mut serial_t, handler: uart_irq_handler,
                              id: uint32_t);
    pub fn serial_irq_set(obj: *mut serial_t, irq: SerialIrq,
                          enable: uint32_t);
    pub fn serial_getc(obj: *mut serial_t) -> ::ctypes::c_int;
    pub fn serial_putc(obj: *mut serial_t, c: ::ctypes::c_int);
    pub fn serial_readable(obj: *mut serial_t) -> ::ctypes::c_int;
    pub fn serial_writable(obj: *mut serial_t) -> ::ctypes::c_int;
    pub fn serial_clear(obj: *mut serial_t);
    pub fn serial_break_set(obj: *mut serial_t);
    pub fn serial_break_clear(obj: *mut serial_t);
    pub fn serial_pinout_tx(tx: PinName);
    pub fn serial_set_flow_control(obj: *mut serial_t, type_: FlowControl,
                                   rxflow: PinName, txflow: PinName);
}
